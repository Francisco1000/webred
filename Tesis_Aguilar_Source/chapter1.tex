%%%%%%%%%%%%%%%%%%%%% chapter1.tex %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Capítulo de síntesis de toda la tesis.
%
%
%%%%%%%%%%%%%%%%%%%%%%%% Universidad de Alicante %%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Síntesis}
\label{c1} % Always give a unique label
% use \chaptermark{}
% to alter or adjust the chapter heading in the running head

A razón de que la tesis doctoral se ha realizado mediante la modalidad de compendio de artículos, este capítulo está dedicado a describir los objetivos, hipótesis y el conjunto de trabajos que la conforman. Además, es resumido el contenido científico de la tesis por medio de una síntesis global de los resultados obtenidos así como de las conclusiones finales. 


\section{Tesis Doctoral como Compendio de Artículos}

Los requisitos que debe cumplir una tesis doctoral para ser realizada en la Universidad de Alicante mediante un compendio de publicaciones fueron definidos por el Pleno de la Comisión de Doctorado de fecha 2 de marzo de 2005. A continuación, se exponen aquellos directamente relacionados con el contenido de la tesis:

\begin{enumerate}

\item \emph{``La tesis debe incluir una síntesis, en una de las dos lenguas oficiales de esta Comunidad Autónoma, en la que se presenten los objetivos, hipótesis, los trabajos presentados y se justifique la unidad temática.''}

\item \emph{``Esta síntesis debe incorporar un resumen global de los resultados obtenidos, de la discusión de estos resultados y de las conclusiones finales. Esta síntesis deberá dar una idea precisa del contenido de la tesis.''}

\item \emph{``Los trabajos deben ser publicados, o aceptados para la publicación, con posterioridad al inicio de los estudios de doctorado. Los artículos en periodo de revisión pueden formar parte de la tesis como apéndices del documento, que debe presentarse adjunta a los artículos publicados.''}

\end{enumerate}

Con el propósito de satisfacer los requisitos, la estructura de la tesis queda constituida en tres partes. La primera parte (Parte ~\ref{p1}) consiste en una síntesis de la tesis. La Parte~\ref{p2} presenta el conjunto de artículos publicados que forman el núcleo de la tesis. Finalmente, la Parte~\ref{p3} consiste en un apéndice donde se presentan tres trabajos, los cuales se encuentran actualmente en proceso de revisión. 

%El primer artículo, consiste en una SLR (\emph{Systematic Literature Review}) acerca del estado de la cuestión en la ingeniería de requisitos en Web, el artículo se ha enviado a el \emph{Journal of Web Engineering} \footnote{http://www.rintonpress.com/journals/jwe/}. En el 

Asimismo, es muy importante subrayar que la tesis doctoral ha sido materializada gracias al apoyo económico otorgado por el Consejo Nacional de Ciencia y Tecnología (CONACyT) México, por medio del Programa de Becas de Estudios de Posgrado en el Extranjero. Finalmente, es necesario destacar el interés y apoyo otorgado por parte de la Universidad Autónoma de Sinaloa, a través del Programa de Formación de Recursos Humanos en Áreas Estratégicas. 

\subsection{Publicaciones Pertenecientes a la Tesis Doctoral}
\label{c1:chapter}

A continuación, se describen brevemente las cuatro publicaciones seleccionadas para que formen parte de la tesis doctoral. El criterio utilizado para la selección consistió en la relevancia y contribución científica de cada una de las publicaciones. Es decir, fueron seleccionados los artículos publicados en revistas indexadas en JCR (\emph{Journal Citation Report}\footnote{http://www.thomsonreuters.com/}) y en congresos ubicados en la clasificación CORE (\emph{Computer Research and Education}\footnote{http://www.core.edu.au/}).

\subsubsection{Capítulo~\ref{c3}}

\emph{J.A. Aguilar, I. Garrig{\'o}s, J.-N. Maz{\'o}n, J. Trujillo. Web Engineering Approaches for Requirements Analysis - A Systematic Literature Review. 6th Web Information Systems and Technologies (WEBIST 2010), Vol. 2, pp. 187-190, 2010.}

El capítulo presenta una revisión sistemática de la literatura con el fin de obtener el estado de la cuestión en lo referente a métodos para la especificación, análisis y modelado de requisitos en ingeniería Web así como las herramientas de soporte ofrecidas por cada uno de los métodos considerados. Los resultados obtenidos muestran, entre otras cosas, que gran parte de las metodologías Web no ofrecen un soporte integral en la etapa de análisis y especificación de requisitos.

\subsubsection{Capítulo~\ref{c4}}

\emph{J.A. Aguilar, I. Garrig{\'o}s, J.-N. Maz{\'o}n, J. Trujillo. An MDA Approach for Goal-oriented Requirement Analysis in Web Engineering. Journal of Universal Computer Science (J.UCS), 16(17): 2475-2494 (2010).}

El capítulo describe la propuesta base de la tesis, la cual consiste en el desarrollo de una metodología para la gestión de requisitos en ingeniería Web. En el capítuo anterior, se realizó una revisión sistemática de la literatura para estudiar las técnicas ingenieriles en el desarrollo de aplicaciones Web, los resultados demuestran que la mayoría de las aproximaciones se enfocan en las etapas de análisis y diseño, por tanto, no ofrecen un soporte integral a la fase de requisitos. La aproximación descrita en este capítulo, ha tomando como sustento las carencias detectadas en el capítulo anterior para desarrollar una aproximación basada en el marco de modelado orientado a objetivos \emph{i*} y en MDA (\emph{Model-Driven Architecture}). La propuesta le permite al diseñador de la aplicación Web derivar la estructura de los modelos conceptuales que conforman la aplicación a partir de la especificación de requisitos. 

\subsubsection{Capítulo~\ref{c5}}

\emph{J.A. Aguilar, I. Garrig{\'o}s, J.-N. Maz{\'o}n. Impact Analysis of Goal-Oriented Requirements in Web Engineering. The 11th  International Conference on Computational Science and Its Applications (ICCSA 2011), June 20-23, 2011, Santander, Spain. Part V, Lecture Notes in Computer Science, Vol. 6786, pp. 421-436, 2011.}

En capítulos anteriores se ha resaltado la importancia de la etapa de análisis y especificación de requisitos en la ingeniería Web, obligada, principalmente, por las características particulares de este tipo de aplicaciones, tales como su audiencia heterogénea y por la evolución constante en las tecnologías de implementación. Este tipo de características originan que la aplicación Web sea propensa a sufrir cambios, por eso, es importante conocer en qué medida impactarán los cambios a los requisitos, así como qué partes de la aplicación Web se verán afectadas. Para lograrlo, es necesario comprender y analizar las dependencias entre los requisitos, es decir, cuales requisitos están relacionados o cuales dependen uno del otro para cumplirse y con ello brindar soporte al diseñador por medio de una mejor gestión y mantenimiento de la aplicación Web. 

En este capítulo, se presenta un algoritmo para manejar las dependencias entre los requisitos funcionales y los requisitos no-funcionales de la aplicación Web en un contexto orientado a objetivos (\emph{goal-oriented}). Con el algoritmo, es posible comprender cuál es el impacto en los requisitos procedente de un cambio en la estructura de modelos conceptuales que conforman la aplicación Web, así como saber qué requisitos necesitan ser implementados para cumplir, en medida de lo posible, los propósitos establecidos en el análisis orientado a objetivos.

%esto ocasiona inconsistencias entre los requisitos, es decir, los requisitos elicitados no reflejan el producto \emph{software} obtenido como resultado del proceso de desarrollo. Por consiguiente, es importante conocer la correspondencia entre los requisitos y el producto \emph{software} obtenido para garantizar, en lo posible, que los requisitos sean reflejados en el producto. Comprender y análizar las dependencias entre los requisitos le permite al diseñador brindar una mejor gestión y mantenimiento de la aplicación Web. En este capítulo, se presenta un algoritmo para manejar las dependencias entre los requisitos funcionales y los requisitos no-funcionales de la aplicación Web en un contexto orientado a objetivos (\emph{goal-oriented}). Con el algoritmo, es posible comprender cuál es el impacto en los requisitos procedente de un cambio en los modelos conceptuales que conforman la aplicación Web, así como saber qué requisitos necesitan ser implementados para cumplir, en medida de lo posible, los proósitos establecidos en el análisis orientado a objetivos.


\subsubsection{Capítulo~\ref{c6}}

\emph{J.A. Aguilar, I. Garrig{\'o}s, J.-N. Maz{\'o}n. A Goal-Oriented Approach for Optimizing Non-Functional Requirements in Web Applications. The 8th  th International Workshop on Web Information Systems Modeling (WISM 2011), held in conjunction with the International Conference on Conceptual Modeling (ER 2011), 31 October - 03 November 2011, Brussels, Belgium. Lecture Notes in Computer Science, Vol. 6999, In press.}

%El contenido de este capítulo aborda la implementación del algoritmo de Pareto 

La idea de considerar a los requisitos no-funcionales desde la etapa de análisis y especificación de requisitos, con el fin de mejorar la calidad de la aplicación a desarrollar, ha sido objeto de investigación en el contexto del desarrollo dirigido por modelos (\emph{Model-Driven Development}). Para lograrlo, es necesario considerar a los requisitos funcionales así como a los no-funcionales desde el inicio del proceso de desarrollo a razón de que los dos poseen la habilidad de satisfacer las necesidades de los \emph{stakeholders} y por lo tanto, según lo establecido en la ISO/IEC 9126-1:2001, en la sección de \emph{Product Quality}, específicamente en  la primera parte \emph{Quality Model}, ambos tipos de requisitos afectan la calidad de un producto de \emph{software}.

En este capítulo se presenta una adaptación del algoritmo Optimización de Pareto para evaluar y seleccionar la configuración de requisitos óptima que maximice los requisitos no-funcionales de la aplicación Web. Una configuración de requisitos óptima esta formada por el sub conjunto de requisitos funcionales que se deberán implementar en los modelos conceptuales de la aplicación. La idea del capítulo se fundamenta en cómo es que la implementación de los requisitos funcionales afecta o beneficia a los requisitos no-funcionales. Para esto, los requisitos no-funcionales deben de ser priorizados de acorde al contexto de los usuarios de la aplicación Web. Finalmente, la solución del algoritmo proporciona al diseñador de la aplicación un conjunto de configuraciones de entre las cuales podrá elegir qué requisitos funcionales implementar (configuración óptima) considerando la prioridad establecida por los \emph{stakeholders} sobre los requisitos no-funcionales.



\subsection{Artículos en Proceso de Revisión Pertenecientes a la Tesis Doctoral}
\label{c1:appendix}

En este apartado, se presentan 3 trabajos que forman parte de la tesis doctoral. Los trabajos están actualmente bajo proceso de revisión.

\subsubsection{Apéndice~\ref{a1}}

\emph{Requirements in Web engineering: a systematic literature review. Este artículo se ha enviado a la revista Journal of Web Engineering (JWE).}

En el artículo se realiza una profunda revisión del estado de la cuestión en lo referente al análisis, especificación y trazabilidad de requisitos en ingeniería Web. Concretamente, se analizan: (i) las técnicas utilizadas por las metodologías ingenieriles en la etapa de análisis y especificación de requisitos, (ii) el tipo de requisitos y la terminología utilizada por cada metodología, (iii) el soporte para trazabilidad y (iv) las herramientas de soporte que ofrecen. 

Cabe destacar que el artículo es una extensión del Capítulo~\ref{c3}, en el que se destaca la importancia de considerar a los requisitos en el desarrollo de sistemas Web. En particular, en la revisión sistemática de la literatura presentada en el apéndice, se ha mejorado el trabajo descrito en el Capítulo~\ref{c3} de la siguiente forma:

\begin{itemize}
	\item La estrategia de búsqueda ha sido mejorada, por lo tanto se han añadido más métodos
a la revisión.

\item El estudio se ha centrado en analizar el proceso de ingeniería de requisitos en el desarrollo de aplicaciones Web, es decir, en qué forma los requisitos son tratados en lo que respecta al análisis, especificación, validación y la gestión de los mismos. 

\item La revisión sistemática analiza el vocabulario que ha sido adoptado por cada 
método de ingeniería Web de una manera metódica y completa mediante el uso de la clasificación propuesta por Escalona y Koch \cite{EscalonaK04}.
\end{itemize}

\subsubsection{Apéndice~\ref{a2}}

\emph{A Goal-Oriented Requirements Engineering Approach to Distribute Functionality in RIAs. Para ser enviado a 24th International Conference on Advanced Information Systems Engineering (CAiSE 2012).}

Como es sabido, las tecnologías de implementación de las aplicaciones Web evolucionan constantemente. Parte de la evolución son las aplicaciones RIAs (\emph{Rich Internet Applications}), las cuales ofrecen, entre otras cosas, una mejor interactividad con el usuario, similar a la ofrecida por las aplicaciones \emph{software} de escritorio. En este trabajo, se presenta la adaptación de la propuesta descrita en el Capítulo ~\ref{c4} para auxiliar al diseñador Web en la distribución de la funcionalidad de la aplicación RIA entre el cliente y el servidor. Para lograrlo, se adaptó el algoritmo Optimización de Pareto para obtener un conjunto de soluciones óptimas, de entre las cuales, de acuerdo con la prioridad establecida por parte del \emph{stakeholder} sobre los requisitos no-funcionales, el diseñador de la aplicación Web será capaz de optimizar los requisitos no-funcionales mediante la distribución de los requisitos funcionales entre el cliente y el servidor.

\subsubsection{Apéndice~\ref{a3}}

\emph{Dealing with dependencies among functional and non-functional requirements for impact analysis in Web engineering. Este artículo se ha enviado a International Journal of Open Source Software and Processes (IJOSSP).}

Este apéndice es una extensión del Capítulo \ref{c5} acerca de la importancia de considerar el análisis de impacto nuestro método orientado a objetivos para el análisis y especificacion de requisitos en Web. En particular, la novedad de la extensión consiste en: (i) la implementación del perfil UML para adaptar el marco de modelado i* en el dominio Web como un metamodelo, (ii) el desarrollo de un prototipo de herramienta para la especificación de requisitos Web como prueba de concepto de nuestra propuesta, (iii) la implementación de las reglas de transformación (con un alto grado de automatización) para derivar los modelos conceptuales de la aplicación Web, y (iv) la implementación del algoritmo para el análisis de impacto en el modelo de requisitos orientado a objetivos.

\subsection{Otras Publicaciones}\label{otraspub}

En el transcurso de la investigación asociada a la tesis doctoral se han publicado 5 artículos en distintos eventos nacionales y/o internacionales. Cabe destacar que los trabajos no han sido incluídos en el núcleo de la tesis, sin embargo, complementan el progreso de la investigación. Los artículos son listados a continuación:

%\subsubsection{Publicaciones en Revistas Internacionales}

\begin{description}

\item[\textbf{J.A. Aguilar}, I. Garrig{\'o}s, J.-N. Maz{\'o}n.] Aproximaciones en Ingeniería Web para el Análisis de Requisitos: una Revisión Sistemática de la Literatura. \emph{Actas del IV Congreso Nacional de Informática y Ciencias de la Computación (CNICC 2009), Mazatlán, Sinaloa, México, 2009.}

\item[\textbf{J.A. Aguilar}, I. Garrig{\'o}s, J.-N. Maz{\'o}n.] Modelos de \emph{weaving} para Trazabilidad de Requisitos Web en A-OOH. \emph{Actas del VII Taller de Desarrollo de Software Dirigido por Modelos (DSDM 2010) en XV Jornadas de Ingeniería de Software y Bases de Datos (JISBD 2010), en conjunto con el Congreso Español de Informática (CEDI), pp. 146-155. SISTEDES, Valencia, España, 2010}. ISSN 1988\-3455.

\item[\textbf{J.A. Aguilar}, I. Garrig{\'o}s, J.-N. Maz{\'o}n.] Modelo Requisitos y Modelo de Dominio, trazabilidad mediante modelos de \emph{Weaving}. \emph{Actas de VIII Jornadas para el Desarrollo de Grandes Aplicaciones de Red (JDARE 2010). GrupoM, Alicante, España, 2010}. ISBN: 978-84-614-3720-7.

\item[\textbf{J.A. Aguilar}, I. Garrig{\'o}s, J.-N. Maz{\'o}n.] Automatic Generation of Conceptual Models from Requirements Specification in Web Engineering using ATL. \emph{Actas de IX Jornadas para el Desarrollo de Grandes Aplicaciones de Red (JDARE 2011). GrupoM, Alicante, España, 2011. Aceptado.}

\item[\textbf{J.A. Aguilar}, I. Garrig{\'o}s, J.-N. Maz{\'o}n.]Una Propuesta Orientada a Objetivos para el Análisis de Requisitos en RIAs. \emph{Actas de XVI Jornadas de Ingeniería de Software y Bases de Datos (JISBD 2011), pp. 211-224. La Coruña, España, 2011. ISBN: 978-84-9749-486-1.}

\end{description}

\section{Hipótesis Inicial y Objetivos de Investigación}
\label{c1s1} 

De forma similar a los sistemas \emph{software} desarrollados exclusivamente para un entorno de escritorio, los sistemas Web necesitan la aplicación de conceptos de ingeniería para obtener éxito en la aplicación final. Para lograrlo, es necesario definir técnicas y enfoques que consideren la gran variedad de usuarios, plataformas y entornos para su implementación. En este sentido, uno de los factores de éxito más importantes en el desarrollo de \emph{software} es la elicitación, gestión y análisis de requisitos. La gestión de requisitos es el proceso de comprender y controlar los cambios en los requisitos de la aplicación \cite{Sommerville96}. 

Sin embargo, en el desarrollo de \emph{software} en ingeniería Web llevar a cabo una correcta gestión de los requisitos es una tarea complicada. Principalmente, esto se debe a que la ingeniería Web enfrenta continuos cambios en lo que respecta a la tecnología de implementación los cuales dificultan la etapa de análisis y especificación de requisitos a razón de las características particulares de las aplicaciones Web, como el caso de: (i) la gran cantidad de información que ofrecen (contenido), (ii) el acceso a los diferentes escenarios donde ofrecen esa información (navegación), (iii) cómo proveer dicha información al usuario o grupos de usuarios (funcionalidad) del sitio Web y (iv), la audiencia heterogénea que tiene acceso a la Web. Como consecuencia de estos factores, los analistas, desarrolladores y diseñadores se enfrentan a retos cada vez más complejos para gestionar el diseño y mantenimiento de las aplicaciones Web. Por lo tanto, definir los requisitos (funcionales y no-funcionales) que el sistema debe cumplir para satisfacer las necesidades de los usuarios es una tarea que necesita una atención especial. 

Actualmente, existen una notable cantidad de aproximaciones metodológicas para el desarrollo de aplicaciones Web (A-OOH \cite{Garrigos09}, UWE \cite{Koch02}, NTD \cite{escalona2004developing}, OOWS \cite{OOWS2001}, etc.) que toman en cuenta la aplicación de distintas técnicas para llevar a cabo el proceso de desarrollo, la mayoría de ellas utilizan reconocidas técnicas de ingeniería de \emph{software} para gestionar correctamente los requisitos de los usuarios, como el caso de UWE (casos de uso) \cite{KochTypesOfReq}. Lamentablemente, la mayoría de las técnicas utilizadas por las metodologías resultan insuficientes para representar características muy particulares de las aplicaciones Web, tales como: la navegación y la audiencia heterogénea. Por lo tanto, es necesaria la inclusión de nuevas técnicas que permitan lidiar con las características particulares de las aplicaciones Web y que además posibiliten la correcta especificación de las necesidades de los diferentes actores implicados. 

Por otro lado, la ingeniería dirigida por modelos (\emph{Model-Driven Engineering}, MDE) es una metodología de trabajo que incorpora un  conjunto de métodos, técnicas y tecnologías para llevar a cabo el proceso de desarrollo en base a modelos. MDE guía el proceso en base a conceptos y reglas tomados directamente de una área de interés determinada, es decir, del dominio del problema \cite{MDE}. Para esto, MDE incorpora conceptos de la ingeniería de software e ingeniería de requisitos, tales como los modelos de madurez \cite{SEI}, los marcos de trabajo conceptuales como las metoddologías ágiles, trazabilidad de los productos de trabajo \footnote{Un producto de trabajo es cualquier artefacto producido por un proceso. Estos artefactos pueden incluir archivos, documentos, piezas de los productos, servicios, procesos y especificaciones \cite{cmmi4development}.} deribados del proceso de desarrollo \cite{SEI} y la evolución del software \cite{Sommerville96}. 

No obstante, el desarrollo dirigido por modelos (\emph{Model Driven Development}, MDD), se manifiesta como un paradigma de desarrollo que abstrae MDE mediante la utilización de modelos como artefactos principales en el proceso de desarrollo de \emph{software}. MDD se ha convertido en una alternativa valiosa para resolver los problemas asociados con el desarrollo de \emph{software} de manera sistemática, estructurada, integrada y completa \cite{aguilarDSDM} por medio del modelado del sistema \emph{software} y su generación a partir de los modelos. Es importante resaltar que MDD sólo proporciona una estrategia general a seguir en el desarrollo de \emph{software} dirigido por modelos, pero no define las técnicas a utilizar. 

En este contexto, la arquitectura dirigida por modelos (\emph{Model Driven Architecture}, MDA) \cite{MDA} surge como un estándar del OMG  (\emph{Object Management Group}) \cite{OMG} que promueve el MDD. MDA está formada por un conjunto de capas y transformaciones que proporcionan un marco conceptual de trabajo en donde encontramos tres tipos de modelos, el primero de ellos es modelo independiente de la computación (\emph{Computational Independent Model}, CIM), utilizado para la especificación de los requisitos de la aplicación a desarrollar, el segundo es el modelo independiente de la plataforma (\emph{Platform Independent Model}, PIM), como su nombre lo indica, se caracteriza por ser independiente de la plataforma de implementación de la aplicación, por ejemplo, un diagrama de clases, y el modelo específico de la plataforma (\emph{Platform Specific Model}, PSM), el cual es obtenido del PIM y contiene la información sobre una plataforma de desarrollo o alguna tecnología en especifico donde será implementada la aplicación final, esto es, el código fuente de la aplicación \cite{MDA}. 

MDA ha tenido un gran impacto en la comunidad de ingeniería Web, esto es debido a las ventajas que ofrece llevar a cabo el proceso de desarrollo de aplicaciones Web mediante el uso de modelos conceptuales, por ejemplo, acortar el tiempo de desarrollo de la aplicación Web, lo cual puede resultar, en algunos casos, en un ahorro en el costo del proyecto. El impacto de MDA en la ingeniería Web ha permitido la llegada de la ingeniería Web dirigida por modelos (\emph{Model Driven Web Engineering}, MDWE) como una nueva aproximación para el desarrollo de aplicaciones Web \cite{kochMDWE, MDWE}. Su supuesto básico es la consideración de los modelos como entidades de primera clase que impulsan el proceso de desarrollo desde el análisis de requisitos hasta la implementación final. Básicamente, cada paso del proceso consiste en la generación de uno o más modelos de salida a partir de uno o más modelos de entrada. Por lo tanto, las transformaciones entre modelos son la clave para completar cada paso del proceso de desarrollo dirigido por modelos.

En la actualidad, MDA ha sido aplicado para el desarrollo de aplicaciones Web por parte de ciertas metodologías tales como OOWS \cite{OOWSMDA}, NDT \cite{NDT} y UWE \cite{KochModelTRans}. Lamentablemente, a pesar que se ha resaltado la importancia de la etapa de análisis de requisitos en Web en distintos trabajos seminales como en \cite{EscalonaK04} y en trabajos más recientes como \cite{Aguilar2010}, algunas metodologías dan poca importancia a la etapa de análisis y especificación de requisitos (OOWS \cite{OOWS2001}, OOHDM \cite{OOHDM1995}, WSDM \cite{WSDM} y HERA \cite{Hera}) y otras, por su parte, consideran la especificación de requisitos a nivel CIM de MDA utilizando técnicas como los casos de uso (UWE \cite{Koch02}) y plantillas textuales \cite{NDT}, técnicas que resultan insuficientes para representar características de las aplicaciones Web como la navegación \cite{Valderas}. En este aspecto, por lo que al autor concierne, el trabajo presentado en la tesis doctoral es el primero que aborda el modelado conceptual de aplicaciones Web a partir del nivel CIM de MDA utilizando técnicas orientadas a objetivos(por medio del marco de trabajo \emph{i*} \cite{istarWiki}) \cite{AguilarJUCS}. 

El uso del enfoque orientado a objetivos (\emph{Goal-oriented Requirements Engineering}, GORE) para la especificación de requisitos permite la elaboración, estructuración, especificación, análisis, negociación, documentación, y la modificación de los requisitos \cite{GORE}. Tal uso se basa en un modelo visual que muestra cómo los objetivos organizacionales, los actores, los escenarios, las tareas y propiedades del dominio están relacionados entre sí y gracias a eso es posible analizar cómo es que los actores efectúan las tareas necesarias para que los objetivos organizacionales puedan ser alcanzados \cite{GOREtour}. 

A razón de que la MDWE utiliza modelos como artefactos principales en el proceso de desarrollo, es posible la obtención, con alto grado de automatización, de la estructura de los modelos conceptuales a nivel PIM directamente de un modelo de requisitos orientado a objetivos. Una de las principales ventajas es que se asegura que los modelos conceptuales obtenidos sean correctos semánticamente y que reflejen los requisitos modelados en el CIM. Además, gracias al análisis orientado a objetivos, es posible ofrecer al diseñador soporte para la gestión de los requisitos, por ejemplo, la visualización de la trazabilidad. Más aun, gracias a la visualización de las relaciones entre los elementos del modelo, es posible analizar el impacto derivado de la eliminación de una tarea u objetivo. 

Cabe destacar que la \textbf{hipótesis de partida} de la investigación asociada a la tesis doctoral consiste en que sí es factible el desarrollo de una metodología MDD-MDA que contemple una etapa integral para el análisis y especificación de requisitos que asista al diseñador en: (i) la comprensión de los objetivos y expectativas de la audiencia heterogénea de una aplicación Web, (ii) brinde soporte en la gestión de los requisitos (trazabilidad y análisis de impacto) y (iii) sea capaz de proveer un conjunto de alternativas de diseño basadas en la prioridad de los requisitos no-funcionales.

El \textbf{objetivo de investigación} de la tesis doctoral es la propuesta de una metodología para el análisis y especificación de requisitos para aplicaciones Web, que considere:

\begin{enumerate}
   \item Una etapa de análisis de requisitos orientada a objetivos para representar las expectativas reales de los stakeholders de la aplicación Web.
   \item Mecanismos para la comprensión de los objetivos de negocio, los cuales, gracias al uso del análisis de requisitos orientada a objetivos, deben de ser alcanzados por medio de la aplicación Web.
    \item Un alto grado de automatización en el desarrollo de aplicaciones Web por medio de un conjunto de transformaciones para obtener la estructura de los modelos conceptuales a partir de la especificación de los requisitos y con esto brindar soporte a la generación del código de la aplicación Web.
   \item Soporte integral para la gestión de los requisitos en aspectos como la trazabilidad y el análisis de impacto. Esto permitirá verificar que los requisitos han sido reflejados en la aplicación final, así como analizar el impacto en los requisitos a razón de la evolución de la aplicación Web.  
   \item Asistir al diseñador al momento de la selección de los requisitos funcionales a implementar a través de alternativas de diseño que consideren el balance y maximización de los requisitos no-funcionales, de esta forma los requisitos no-funcionales son considerados desde la etapa de análisis y especificación de requisitos con el fin de mejorar la calidad de la aplicación Web a desarrollar.
  
\end{enumerate}
 

\section{Resumen del Contenido de la Tesis Doctoral}
\label{c1s3}

El objetivo de investigación de la tesis doctoral se aborda en dos etapas, la primera es la definición de una propuesta orientada a objetivos para el análisis y especificación de requisitos en ingeniería Web. La finalidad de la primera etapa es la obtención de la estructura de los modelos conceptuales de la aplicación Web. La segunda, consiste en la especificación y aplicación de técnicas para la gestión de requisitos, concretamente, aquellas relacionadas con la trazabilidad de requisitos, análisis de impacto y alternativas de diseño en base a la maximización de requisitos no-funcionales.

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/Propuesta1.png}
\end{center}
\caption{Visión global de la propuesta de la tesis doctoral.}
\label{fig:propuesta}
\end{figure}

En la Figura \ref{fig:propuesta} se presenta la visión global de la propuesta que se presenta en la tesis doctoral. Concretamente, el estudio llevado a cabo para obtener el estado de la cuestión en cuando a la ingeniería de requisitos en el desarrollo de aplicaciones Web (\textit{Managing Requirements in the Development of Web Applications}) es descrito en el Capítulo \ref{c3} y en el Apéndice \ref{a1}. El Capítulo \ref{c4} presenta el método propuesta para el análisis y especificación de requisitos para aplicaciones Web (\textit{Requirements Analisys and Specification}). La validación de requisitos (\textit{Requirements Validation}), específicamente en lo que a trazabilidad se refiere, se describe en el apartado titulado \label{otraspub} (``Otras Publicaciones''), esto es porque no forma parte del núcleo de la tesis. Finalmente, la gestión de requisitos (\textit{Requirements Management}), se puntualiza en los Capítulos \ref{c5} y \ref{c6}, así como en el Apéndice \ref{a3} de la tesis.


\subsection{Una Aproximación Orientada a Objetivos para el Análisis de Requisitos en Ingeniería Web}\label{modelos}

En este apartado se resume la propuesta para el análisis y especificación de requisitos en ingeniería Web, aplicada por medio del marco de modelado orientado a objetivos \emph{i*} y el método de ingeniería Web A-OOH (\emph{Adaptive Object-Oriented Hypermedia}) \cite{AguilarJUCS, irene08, Garrigos09}. 

A-OOH \cite{irene08}, es la extensión del método OOH (\emph{Object-Oriented Hypermedia}) \cite{GomezOOH} con soporte de personalización. El proceso de desarrollo de A-OOH esta basado en MDA \cite{MDA}, es decir, la aplicación Web es obtenida a partir de una serie de modelos conceptuales. Los modelos conceptuales corresponden al nivel PIM de la arquitectura MDA como puede verse en Fig. \ref{fig:approach}, estos son: 

%los requisitos de la aplicación Web son definidos en un nivel CIM

\begin{itemize}
   \item \textbf{Modelo de dominio}. El modelo de dominio de A-OOH se expresa como un diagrama de clases UML (\emph{Unified Modeling Language}) \cite{UML}. El modelo refleja la parte estática de la aplicación Web encapsulando su estructura y funcionalidad. Los elementos principales para el modelado de un diagrama de clases son las clases (con sus atributos y operaciones) y sus relaciones.
	
	\item \textbf{Modelo de navegación}. El modelo de navegación de A-OOH se compone de nodos de navegación y las relaciones entre ellos. El modelo indica los caminos de navegación que el usuario puede seguir en la Web (enlaces de navegación). Hay tres tipos de nodos: (i) clases navegacionales (que son vistas parciales de las clases de dominio), (ii) destinos navegacionales (que agrupan elementos del modelo que colaboran en el cumplimiento de uno o más requisitos de navegación del usuario) y (iii) colecciones (que son estructuras, posiblemente jerárquicas, que se definen entre clases de navegación o destinos navegacionales). La colección más común es la colección de clasificación (\emph{C-collection}), que actúa como un mecanismo de abstracción para el concepto de \emph{menú} agrupando enlaces de navegación. Con respecto a los enlaces de navegación, A-OOH define dos tipos principales: enlaces de travesía (\emph{Transversal-links}) (definidos entre dos nodos de navegación) y enlaces de servicio (\emph{Service-links}), en donde la navegación sucede al activar una operación que modifica la lógica de negocio y además implica la navegación a un nodo mostrando información cuando la ejecución del servicio ha finalizado.
   
   \item \textbf{Modelo de presentación}. El modelo permite definir la interfaz gráfica de la aplicación Web, por ejemplo, el tipo de fuente utilizada en el texto, el color, etc.
  
   \item \textbf{Modelo de personalización}. El modelo es utilizado para la especificación de estrategias de personalización.
   
   \item \textbf{Modelo de usuario}. Permite la descripción de los usuarios en términos de información personal, sus relaciones con un dominio en particular y las acciones de navegación realizadas en tiempo de ejecución. La estructura de la información necesaria para la personalización también se describe en este modelo.   
\end{itemize}

\begin{figure}
\begin{center}
\includegraphics[width=0.8\textwidth]{img/CIMenAOOH.png}
\end{center}
\caption{La propuesta de la tesis doctoral integrada como CIM en el método Web A-OOH.}
\label{fig:approach}
\end{figure}


\subsubsection{Especificación del Modelo de Requisitos a Nivel CIM}\label{especificacion}

El primer paso de la propuesta es la especificación y el modelado de los requisitos de la aplicación Web. Para una explicación más amplia el lector puede referirse al Capítulo \ref{c4} de la tesis doctoral.

Los requisitos Web se definen en un modelo independiente de computación (CIM) utilizando el marco de modelado de requisitos \emph{i*}. El marco de modelado \emph{i*}  \cite{Yu95, Yu97} es uno de los más utilizados para analizar los objetivos de los \emph{stakeholder's} \footnote{Las personas u organizaciones que afectan o son afectados directa o indirectamente por el proyecto de desarrollo de \emph{software} en una forma positiva o negativa \cite{Sommerville96}.}, nombrados actores en \emph{i*}, y cómo el sistema a diseñar debería satisfacerlos. Además, \emph{i*} permite razonar acerca de cómo estos objetivos pueden contribuir a la selección de diferentes alternativas de diseño según su viabilidad. Con el fin de motivar esta parte de la investigación, se ha realizado una revisión del estado de la cuestión (ver Capítulo \ref{c3} y Apéndice~\ref{a1}) acerca de las técnicas utilizadas para el análisis y especificación de requisitos en ingeniería Web.

El marco de modelado \emph{i*} consiste básicamente en dos modelos: el modelo SD (\emph{Strategic Dependency}) para especificar las relaciones de dependencia entre varios actores en un contexto organizacional y el modelo SR (\emph{Strategic Rationale}), utilizado para describir los intereses y preocupaciones del actor y como es que podrían abordarse. El modelo SR permite el modelado de las relaciones de asociación entre cada actor y sus dependencias, por tanto, proporciona información acerca de cómo los actores llegan a sus objetivos. El modelo SR incluye sólo los elementos considerados lo suficientemente importantes como para influir en el alcance de un objetivo. El modelo SR muestra las dependencias de los actores mediante la inclusión del modelo SD. En torno a estas dependencias, el modelo SR especifica elementos intencionales, tales como (\emph{Goals}), tareas (\emph{Tasks}), recursos (\emph{Resources}) y \emph{Softgoals} (Tabla \ref{tab:istarsymbols}). En comparación con el modelo SD, los modelos SR proporcionan un nivel de modelado más detallado, debido a que permiten modelar las relaciones internas e intencionales dentro de los actores. Las relaciones intencionales son enlaces del tipo \emph{Meands-end} y representan formas alternativas para satisfacer objetivos; los \emph{Decomposition-links} representan los elementos necesarios para que una tarea sea realizada; o los \emph{Contribution-links} que sirven para modelar cómo es que un elemento intencional contribuye a la satisfacción de una (\emph{Softgoal}). En la Tabla \ref{tab:istarsymbols} se describen los elementos más importantes del marco de modelado \emph{i*}, para información más extendida el lector puede consultar \cite{istarWiki, Yu95, Yu97}. 

%\begin{table}
%\centering
%\tiny
%\caption{La notación de \emph{i*}.}\label{tab:istarsymbols}
%\begin{tabular}{|c|c|c|c|}
%\hline
%\textbf{Símbolo} & \textbf{Nombre} & \textbf{Símbolo} & \textbf{Nombre}\\
%\hline
%\includegraphics[height=3mm]{img/dependency.eps} & SD Model & \includegraphics[height=3mm]{img/boundary.eps} & SR Model\\
%\includegraphics[height=3mm]{img/iactor.eps} & Actor & \includegraphics[height=3mm]{img/goal.eps} & Goal \\
%\includegraphics[height=3mm]{img/task.eps} & Task & \includegraphics[height=3mm]{img/resource.eps} & Resource\\
%\includegraphics[height=3mm]{img/softgoal.eps} & Softgoal & \includegraphics[height=3mm]{img/means-end.eps} & Means-end link\\
%\includegraphics[height=3mm]{img/decomposition.eps} & Task-decomposition link & \includegraphics[height=3mm]{img/contribution.eps} & Contribution link\\
%\hline
%\end{tabular}
%\end{table}

\begin{table}
\caption{Principales elementos para el modelado en \emph{i*}}
\label{tab:istarsymbols}
\begin{tabular}{p{0.3\textwidth}p{0.2\textwidth}p{0.4\textwidth}}
\hline\noalign{\smallskip}
Elemento & Icono& Descripción  \\
\noalign{\smallskip}\hline\noalign{\smallskip}
\textsc{Actor} & (\includegraphics[height=3mm]{img/iactor.eps}) & Es una entidad que lleva a cabo acciones para cumplir con sus objetivos. Se relaciona con varios elementos intencionales (objetivo, tarea o recurso).\\
\textsc{Goal} & (\includegraphics[height=3mm]{img/goal.eps}) & Representa una condición o estado que el actor le gustaría alcanzar. Lamentablemente no detalla como es que se satisfará el objetivo.\\
\textsc{Task} & (\includegraphics[height=3mm]{img/task.eps}) & Representa una manera particular de hacer algo (alcanzar un objetivo). \\
\textsc{Softgoal} & (\includegraphics[height=3mm]{img/softgoal.eps}) & Representan criterios de calidad. Son utilizadas cuando los objetivos del \emph{stakeholder} no son precisos o sus criterios de éxito no están claramente definidos.\\
\textsc{Resource} & (\includegraphics[height=3mm]{img/resource.eps}) & Es una entidad que debe estar disponible para su uso (datos).\\
\textsc{Means-ends} & (\includegraphics[height=3mm]{img/means-end.eps}) & Son asociaciones que describen cómo se alcanzan los objetivos, es decir, los posibles caminos para satisfacer un objetivo. \\
\textsc{Decomposition} & (\includegraphics[height=3mm]{img/decomposition.eps}) & Son asociaciones que definen elementos adicionales necesarios para llevar a cabo una tarea. \\
\noalign{\smallskip}\hline\noalign{\smallskip}
\end{tabular}
\end{table}

Por otra parte, el marco de modelado \emph{i*} resulta insuficiente para representarlas por sí solo las características particulares de las aplicaciones Web, tales como el contenido que ofrecen, la navegación, la funcionalidad y la audiencia heterogénea (para más información consultar Capítulo \ref{c3} y Apéndice~\ref{a1}). Por tal motivo, \emph{i*} debe de adaptarse al dominio Web para poder ser utilizado en la especificación y análisis de requisitos. Esto permitirá modelar a los \emph{stakeholders} con sus objetivos y las relaciones existentes entre ellos para satisfacerlos. Para realizar la adaptación del marco de modelado \emph{i*} al dominio Web nuestra propuesta utiliza la taxonomía de requisitos Web presentada en \cite{EscalonaK04}, la cual clasifica a los requisitos Web en 6 tipos. Estos son descritos a continuación:

\begin{itemize}
   
   \item \textbf{Requisitos de contenido (\emph{Content})}. Con este tipo de requisitos se define el contenido que el sitio Web presenta a sus usuarios. Considerando como ejemplo base una librería \emph{on-line}, algunos ejemplos pueden ser:  ``información del libro'' o ``categorías del producto''.
  
   \item \textbf{Requisitos de servicio (\emph{Service})}. Este tipo de requisito hace referencia a la funcionalidad interna que la aplicación Web debe proveer a los usuarios. Continuando con el ejemplo de la librería \emph{on-line}, ejemplo de requisitos de servicio son: ``registrar un nuevo cliente'', ``agregar un producto'', etc.
   
   \item \textbf{Requisitos de navegación (\emph{Navigational})}. Un sistema Web debe también definir caminos de navegación disponibles para los usuarios. Algunos ejemplos, en base a la librería \emph{on-line} son: ``consultar productos por categoría'', ``consultar el carrito de compras'', etc.
   
   \item \textbf{Requisitos de interfaz (\emph{Layout})}. Los requisitos también pueden definir la interfaz visual para los usuarios. Por ejemplo: ``presentar un estilo diferente para los adolescentes''.
   
   \item \textbf{Requisitos de personalización (\emph{Personalization})}. El diseñador puede especificar las acciones de personalización a ser ejecutadas en el sitio Web. Por ejemplo: ``adaptar el estilo de la fuente para las personas con deficiencia visual''.
   
   \item \textbf{Requisitos no funcionales (\emph{Non-functional requirements})}. Estos requisitos representan criterios de calidad que el sistema debe conseguir. Algunos ejemplos de estos requisitos pueden ser: ``eficiencia'', ``atraer más usuarios'' y ``buena experiencia del usuario''.
\end{itemize}

Finalmente, para poder utilizar el marco de modelado \emph{i*} dentro de MDA se ha implementado un metamodelo. El metamodelo se implementó utilizando la tecnología EMF (\emph{Eclipse Modeling Framework}) de Eclipse \cite{ECLIPSE} (Fig. \ref{fig:SeccionRequisitosWebMetamodelo}). Los elementos intencionales de \emph{i*} fueron extendidos con nuevas clases para representar cada uno de los tipos de requisitos Web descritos anteriormente (\emph{Navigational}, \emph{Service}, \emph{Personalization}, \emph{Layout} y \emph{Content}). De esta forma, los requisitos \emph{Navigational}, \emph{Service}, \emph{Personalization} y \emph{Layout} son instancias del elemento \emph{Task} del marco de modelado \emph{i*}, por lo tanto, se representarán visualmente por medio de la figura (\includegraphics[height=3mm]{img/task.eps}) y el requisito \emph{Content}, del elemento \emph{Resource}, será representado por la forma (\includegraphics[height=3mm]{img/resource.eps}) de \emph{i*}. 

Por último, es importante destacar que los requisitos no-funcionales de la aplicación Web se modelan directamente utilizando el elemento \emph{Softgoal}, por tanto, cuando se lleve a cabo la especificación de requisitos utilizando esta propuesta, el concepto de requisito no-funcional corresponderá al concepto de \emph{Softgoal} del marco de modelado \emph{i*} y se representará visualmente con la imagen (\includegraphics[height=3mm]{img/softgoal.eps}). 

%\begin{figure}
%\begin{center}
%\includegraphics[width=\textwidth]{img/SeccionRequisitosWebMetamodelo.eps}
%\end{center}
%\caption{Extracto de metamodelo de requisitos Web del método A-OOH.}
%\label{fig:reqmetamodel}
%\end{figure}

A continuación, se resume la generación de la estructura de los modelos conceptuales de A-OOH. Se remite al lector a los capítulos
específicos de la tesis doctoral para una explicación más detallada (Capítulo \ref{c4}).

%dominio y navegación

\subsubsection{Generación de los Modelos Conceptuales a nivel PIM}\label{reglas}

Definidos los requisitos en un CIM, el siguiente paso consiste en utilizarlos para derivar la estructura de los modelos conceptuales de la aplicación Web. Para lograrlo, es necesario que los modelos cumplan con la sintaxis abstracta de un dominio especifico, es decir, que sean conformes a un metamodelo. A continuación se describen los metamodelos utilizados para la derivación de los modelos conceptuales a nivel PIM de MDA.

UML (\emph{Unified Modeling Language}) \cite{UML} es el lenguaje de modelado estándar utilizado para la derivación del modelo de dominio de A-OOH. El metamodelo describe los objetos, atributos y relaciones necesarias para representar los conceptos de UML dentro de una aplicación de \emph{software}. Los modelos estáticos son presentados en diagramas llamados Diagramas de Clases. El propósito de un diagrama de clases es representar a las clases dentro de un modelo. En una aplicación orientada a objetos, las clases tienen atributos (variables miembros), operaciones (funciones miembro) y relaciones con otras clases. Estas características aplican perfectamente para la representación del modelo de dominio de A-OOH.

\begin{landscape}
\begin{figure}
\begin{center}
\includegraphics[width=1.8\textwidth]{img/WebRequirementsMetamodel.png}
\end{center}
\caption{Metamodelo para la especificación de requisitos Web con \emph{i*}.}
\label{fig:SeccionRequisitosWebMetamodelo}
\end{figure}
\end{landscape}

Por otra parte, A-OOH dispone de un metamodelo \cite{irene08} para representar las rutas de navegación que el usuario puede seguir durante su interacción con la aplicación Web. En la Figura \ref{fig:NavMetamodel} se muestra el metamodelo de navegación utilizado en A-OOH. Los elementos principales del metamodelo son: (i) Nodo Navegacional (\emph{Navigational Node}) y (ii) Enlace Navegacional (\emph{Navigational Link}).


El Nodo Navegacional representa vistas restringidas de los conceptos del dominio y sus relaciones indican las rutas de navegación que el usuario de la aplicación Web puede seguir. Existen tres tipos diferentes de Nodos Navegacionales, los cuales se describen a continuación:

\begin{itemize}
\item \textbf{Clases de Navegación} (\emph{Navigational Classes}), son clases del dominio enriquecidas con atributos y métodos cuya visibilidad ha sido restringida, dependiendo de los permisos de acceso del usuario y de los requisitos de navegación. Es representada por una clase UML estereotipada como \emph{NavigationalClass}.

\item \textbf{Objetivos de Navegación} (\emph{Navigational Targets}), agrupan los elementos del modelo que colaboran en el cumplimiento de cada requisito de navegación del usuario. Son representados utilizando la notación UML de paquetes con el estereotipo \emph{NavigationalTarget}.

\item \textbf{Colecciones} (\emph{Collections}), son estructuras jerárquicas definidas en Clases Navegacionales u Objetivos Navegacionales. Proveen al usuario de la aplicación Web nuevas formas de accesar a la información. La colección más común es \emph{C-Collection} (\emph{Clasifier Collection}), la cual actúa como un mecanismo de abstracción para el concepto de \emph{menú}, agrupa de esta forma Enlaces Navegacionales (\emph{Navigational Links}). Otra colección importante es la llamada \emph{S-Collection} (\emph{Selector Collection}) mediante la cual podemos representar un mecanismo de selección. Las colecciones son representadas por medio de una clase UML estereotipada como \emph{NavigationalC-Collection} o \emph{NavigationalS-Collection}.
\end{itemize}



El Enlace Navegacional define las rutas de navegación que el usuario puede seguir a través de la aplicación Web. A-OOH en su metamodelo de navegación define dos tipos principales de enlaces (\emph{links}):

\begin{itemize}
\item \textbf{T-Links} (\emph{Transversal Links}), son enlaces definidos entre dos nodos navegacionales (clases navegacionales, colecciones u objetivos navegacionales). La navegación es realizada para mostrar información a través de la interfaz del usuario sin modificar en absoluto la lógica de negocio. Estos tipos de enlaces son representados por el estereotipo \emph{TransversalLink}.

\item \textbf{S-Link} (\emph{Service Links}), con estos tipos de enlaces la navegación es realizada para activar una operación, la cual, en forma opuesta a los \emph{T-Links} modifica la lógica del negocio y además implica que la navegación a un nodo muestre información cuando termine la ejecución del servicio. Se establece cuando un servicio de la clase navegacional es activado. Estos tipos de ligas son representados por el estereotipo \emph{ServiceLink}  y tiene asociado el nombre del servicio que lo invoco.
\end{itemize}


%Un modelo representa algún aspecto de un sistema \emph{software} y conforma con el metamodelo con el que está expresado. Una vez se han presentado y descrito los metamodelos utilizados por A-OOH se procederá a explicar la derivación de los modelos conceptuales de dominio y navegación.

Una vez han sido explicados los metamodelos de dominio y navegación de A-OOH, el siguiente paso consiste en describir sus respectivos modelos. El modelo de dominio en A-OOH encapsula la estructura y funcionalidad de los conceptos relevantes del dominio de la aplicación Web y también refleja la parte estática de la misma, se representa como un diagrama de clases en notación UML \cite{UML}. El objetivo consiste en obtener el esqueleto del modelo de dominio de A-OOH a partir del modelo de requisitos en \emph{i*} por medio de un conjunto de reglas de transformación modelo a modelo (M2M) \cite{OMG/QVT} (ver Capítulo \ref{4} y Apéndice \ref{a3}). 

\begin{landscape}
\begin{figure}
\begin{center}
%\includegraphics[width=1.5\textwidth]{img/NavigationalMetamodel.png}
\includegraphics[width=18.5cm,height=13.5cm]{img/NavigationalMetamodel.png}
\end{center}
\caption{Metamodelo de Navegación de A-OOH.}
\label{fig:NavMetamodel}
\end{figure}
\end{landscape}

%Con las reglas, se obtendrá un modelo de \emph{weaving} para mantener enlaces bidireccionales entre los elementos de ambos modelos (a nivel de sus respectivos elementos). A continuación se describen las principales reglas QVT para generar el modelo de dominio y el modelo de \emph{weaving}:

\begin{itemize}
\item \textbf{\emph{Content2DomainClass}}. El dominio origen de la relación está compuesto por un conjunto de elementos que representan un requisito del tipo \emph{Content}. Cuando se detecta este patrón en el modelo de entrada se fuerza la creación de una clase tipo \emph{Class UML} en el modelo destino (modelo de dominio). Por tanto, por cada requisito de contenido, se obtiene una clase en el modelo de dominio (Figura \ref{fig:content2Domain}).

\begin{figure}
\begin{center}
\includegraphics[width=0.8\textwidth]{img/content2domainclass.eps}
\end{center}
\caption{Regla QVT para obtener las clases del modelo de dominio.}
\label{fig:content2Domain}
\end{figure}

\item \textbf{\emph{Service2Operation}}. La regla detecta un conjunto de elementos en el modelo de entrada (modelo de requisitos) que corresponden con un requisito \emph{Service} asociado a un requisito \emph{Content}. Una vez detectado este patrón de elementos, se crea en el modelo de salida (modelo de dominio) una clase \emph{Operation} en la clase del modelo de dominio correspondiente (Figura \ref{fig:service2operation}).

\begin{figure}
\begin{center}
\includegraphics[width=0.8\textwidth]{img/service2operation.eps}
\end{center}
\caption{Regla QVT para obtener las operaciones de las clases del modelo de dominio.}
\label{fig:service2operation}
\end{figure}

\item \textbf{\emph{Navigation2Relationship}}. Esta relación permite crear asociaciones entre clases en el modelo de dominio. Existen dos requisitos \emph{Content} como origen, si los dos requisitos se usan para cumplir el mismo requisito de navegación, entonces se crea una clase \emph{Association} entre las clases del modelo de dominio que las representan (Figura \ref{fig:navigation2relationship}).

\begin{figure}
\begin{center}
\includegraphics[width=0.8\textwidth]{img/navigation2relationship.eps}
\end{center}
\caption{Regla QVT para obtener las relaciones entre las clases del modelo de dominio A-OOH.}
\label{fig:navigation2relationship}
\end{figure}
\end{itemize}


Como se mencionó anteriormente, el modelo de navegación está compuesto de nodos navegacionales y sus respectivas relaciones para indicar las rutas de navegación de la aplicación Web. Para derivar el modelo de navegación los requisitos tomados en cuenta para generar un conjunto de reglas de transformación QVT son los requisitos de contenido (\emph{Content}), servicio (\emph{Service}), navegación (\emph{Navigational}) y personalización (\emph{Personalization}). En este caso, las reglas QVT para la obtención del modelo de navegación son las siguientes:


\begin{itemize}

\item \textbf{\emph{Navigation2NavClass}}. La regla de transformación detecta cada requisito navegacional, derivando su correspondiente clase. En concreto, cuando se detecta en el modelo origen un requisito \emph{Navigational} unido a un requisito \emph{Content}, entonces se crea una clase estereotipada como \emph{NavigationalClass} en el modelo destino. Además cada una de las nuevas clases es el destino de una nueva asociación \emph{TransversalLink} desde una \emph{C-Collection} previamente creada por la función \emph{createMenu} que se encuentra en la cláusula \emph{when} (Figura \ref{fig:nav2navclass}).

\begin{figure}
\begin{center}
\includegraphics[width=0.8\textwidth]{img/nav2navclass.eps}
\end{center}
\caption{Regla QVT para obtener las clases navegacionales.}
\label{fig:nav2navclass}
\end{figure}

\item \textbf{\emph{Personalization2NavClass}}. La regla es similar a la anterior pero detectando los requisitos de personalización que tienen un requisito de contenido asociado. Se derivan en el modelo de navegación los mismos elementos que en la regla anterior.


\item \textbf{\emph{Navigation2TransversalLink}}. Permite crear asociaciones entre clases navegacionales en el modelo de navegación. Existen dos modelos origen con el fin de detectar requisitos \emph{Content}, si los dos requisitos se usan para cumplir con el mismo requisito de navegación (comprobado en la cláusula \emph{when} con la operación \emph{SameNavigationOrigin)}, entonces se crea una asociación \emph{TransversalLink} entre las clases del modelo de navegación que las representan.

\item \textbf{\emph{Service2ServiceAndSLink}}. La relación detecta un conjunto de elementos en el modelo origen que corresponden con un requisito \emph{Service} asociado a un requisito \emph{Content}. Una vez detectado este patrón de elementos, se crea en el modelo destino una clase \emph{Operation} en la clase del modelo de navegación correspondiente. Además, se crea una asociación \emph{ServiceLink} para cada operación añadida. El nuevo enlace de servicio se asocia a una nueva clase navegacional (\emph{NavigationalClass}) destino. Antes de ejecutarse la transformación, se debe verificar que se cumple con las sentencias dispuestas en la cláusula \emph{when}, en este caso \emph{Navigation2NavClass} y \emph{Personaliza tion2NavClass}, con el fin de crear en el modelo destino todas las posibles clases de navegación a partir de cada uno de los requisitos \emph{Content} en el modelo origen.


\end{itemize}

Finalmente, es importante mencionar que los modelos conceptuales derivados son modelos iniciales que servirán como punto de partida para el diseñador Web, de esta forma es posible proveer un alto grado de automatización en el proceso de desarrollo de aplicaciones Web dirigido por modelos.

\subsection{Gestión de Requisitos en A-OOH}
\label{c1:gestion}

Las metodologías para el desarrollo de aplicaciones Web aún no responden a las exigencias actuales de este tipo de \emph{software} \cite{Aguilar2010}. En ese aspecto, las necesidades y expectativas de los \emph{stakeholders} no son captadas satisfactoriamente. De ahí que una considerable cantidad de proyectos de desarrollo no alcancen a cumplir sus objetivos, y como consecuencia de esto, la aplicación Web no cumple con las expectativas reales de los usuarios \ref{BolchiniP04, Bolchini2003, EscalonaK04}. 

Las principales causas de estos problemas son la gestión insuficiente de los requisitos funcionales y no-funcionales, la comunicación ambigua e imprecisa entre los \emph{stakeholders}, las inconsistencias no detectadas entre los requisitos, diseño y programación, así como la propagación de cambios sin analizar su impacto. En este sentido, es necesario recordar que los errores más comunes y más costosos de reparar, así como los que más tiempo consumen, se deben a una inadecuada ingeniería de requisitos. Actividades propias de esta área, como la especificación o la gestión de requisitos, son algunas de las consideradas más críticas en ingeniería Web y en la ingeniería de \emph{software} en general.

Por otra parte, el uso de técnicas orientadas a objetivos \cite{Yu95} para la especificación de requisitos en ingeniería Web \cite{Bolchini2003, Garrigos09} permite reflejar desde las etapas iniciales del proceso de desarrollo los objetivos, tareas y relaciones de los \emph{stakeholders}, lo que proporciona los elementos necesarios para que se consideren las necesidades y objetivos del usuario de la aplicación Web. Sin embargo, a pesar de que los requisitos son especificados en un modelo conceptual, los \emph{stakeholders} necesitan observar que han sido reflejados correctamente en la aplicación Web final. Una forma de brindar soporte a esta necesidad es proveer al diseñador Web con una etapa de requisitos que considere la gestión de los mismos.


Por tanto, la propuesta presentada en la tesis se ha extendido para proveer al diseñador con soporte para: (i) trazabilidad de requisitos (CIM-PIM) \cite{aguilarDSDM} (Apéndice \ref{a3}), (ii) evaluar el impacto derivado de un cambio en los modelos conceptuales (análisis de impacto) \cite{AguilarICCSA} (Capítulo \ref{c5}) y (iii) seleccionar alternativas de diseño considerando la maximización y/o balance de los requisitos no-funcionales \cite{AguilarWISM} (Capítulo \ref{c6}).

\subsubsection{Trazabilidad de Requisitos en A-OOH}
\label{c1:trazabilidad}

En el campo de la ingeniería Web dirigida por modelos, realizar el seguimiento de los requisitos durante la etapa de desarrollo de la aplicación Web hasta su implementación final es una tarea compleja \cite{AguilarICCSA}. Esto se debe a que en ingeniería Web se deben generar varios modelos conceptuales a partir de los requisitos como son el modelo de dominio o de navegación. Además, debido al desarrollo gradual de las necesidades de los usuarios de la aplicación Web, los modelos cambian constantemente, por lo que la trazabilidad de los requisitos se hace indispensable.

La trazabilidad de requisitos se define como la capacidad de describir y seguir la vida de un requisito, en ambas direcciones \cite{gotel1994analysis}: (i) determinar qué partes del modelo están relacionadas con cada uno de los requisitos, y (ii) determinar qué requisitos dieron origen a qué partes del modelo. En la actualidad, existen dos estrategias para gestionar y almacenar la información para la trazabilidad entre modelos: (i) la información se puede integrar en los modelos a los que se refiere y (ii) la información de trazabilidad se puede almacenar por separado en otro modelo \cite{barbero2007traceability}. La primera de estas dos opciones tiene como desventaja que si la información es almacenada en el mismo modelo, el modelo será contaminado con información poco relevante para el contexto del modelo y por lo tanto, será difícil de mantener y utilizar. Por otro lado, la segunda estrategia consiste en almacenar la información en un modelo aparte. De esta forma se pueden corregir las desventajas mencionadas.

Con el fin de brindar soporte para la trazabilidad de requisitos en A-OOH \cite{aguilarDSDM} se ha utilizado el concepto de modelo de \emph{weaving}. Un modelo de \emph{weaving} es un tipo de modelo formado por enlaces y referencias a elementos, los enlaces están dirigidos a las referencias de los elementos de un modelo origen y de un modelo destino \cite{bezivin2005unification}. A continuación, se presenta el metamodelo base para \emph{weaving} \cite{del2006weaving} y una extensión para proveer a dicho metamodelo con elementos útiles para representar la trazabilidad entre modelos \cite{barbero2007traceability}. El metamodelo se muestra en la Figura \ref{fig:weavingmetamodel}:

\begin{itemize}
\item \textbf{\emph{WElement}}. Es el elemento base del cual los elementos restantes heredan, esta formado por los atributos nombre y descripción.
\item \textbf{\emph{WModel}}. Representa el elemento raíz que contiene a todos los elementos del modelo. Está compuesto por las referencias y relaciones a los modelos de entrada y salida.
\item \textbf{\emph{WLink}}. Sirve para representar un enlace entre los elementos de los modelos de entrada y salida.
\item \textbf{\emph{WLinkEnd}}. Este elemento representa la referencia origen o destino de un \emph{WLink}.
\item \textbf{\emph{WElementRef}}. Este elemento se asocia a una función de identificación, creando un identificador único para cada uno de elementos de los modelos de entrada y salida, por tanto \emph{WElementRef} permite referenciar el mismo elemento de los modelos de entrada y salida por diversos elementos \emph{WLinkEnd}.
\item \textbf{\emph{WModelRef}}. Representa un identificador único de un modelo.
\end{itemize}

%\begin{landscape}
\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/WeavingMetamodel.png}
\end{center}
\caption{Metamodelo de \emph{weaving}.}
\label{fig:weavingmetamodel}
\end{figure}
%\end{landscape}


Por otra parte, en la Figura \ref{fig:tracemetamodel}, se ilustra la extensión del metamodelo para \emph{weaving} que permite la representación de la trazabilidad. La extensión la forman los siguientes elementos:

\begin{itemize}
\item \textbf{\emph{TraceModel}}. Es el elemento que representa al modelo de trazabilidad, está integrado por referencias a otros modelos.
\item \textbf{\emph{TraceModelRef}}. Representa la referencia a otros modelos, es decir, es un único identificador para los modelos que conforman el modelo de trazabilidad.
\item \textbf{\emph{ElementRef}}. Es un identificador para señalar cada elemento que integran los modelos ligados.
\item \textbf{\emph{TraceLink}}. Un enlace de rastreo, utilizado para representar las correspondencias entre las referencias de los elementos de los modelos enlazados. Como información de trazabilidad, almacena el nombre de la regla de transformación que ha sido ejecutada.
\item \textbf{\emph{TraceLinkEnd}}. Su función es similar al elemento \emph{WLinkEnd} del cual hereda, pues permite crear una relación uno a muchos (1-N) entre las referencias de los elementos del modelo de entrada (\emph{sourceElements}) y los del modelo de salida (\emph{targetElement}).
\end{itemize}

%\begin{landscape}
\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/TraceabilityMetamodel.png}
\end{center}
\caption{Extensión del metamodelo de \emph{weaving} para trazabilidad.}
\label{fig:tracemetamodel}
\end{figure}
%\end{landscape}

Los \emph{trace links} han sido introducidos dentro de las reglas de transformación que generan los elementos de los modelos conceptuales de A-OOH. Asimismo, es generado un modelo de trazabilidad (\emph{trace model}) al ejecutarse el conjunto de transformaciones por primera vez. Para un mejor entendimiento, se ha utilizado el lenguaje estándar QVT \cite{OMG/QVT} para representar en la Figura \ref{fig:Content2DomainWithTrace} la incorporación de los \emph{trace links} dentro de la regla \emph{Content2DomainClass}. En la figura, se observa que por cada vez que se encuentre un requisito \emph{Content} en el modelo de entrada (modelo de requisitos \emph{i*}), se creará en el modelo de dominio una clase del tipo \emph{Class} de UML, y al mismo tiempo, para referenciar a los elementos de los modelos de entrada y salida, se creará un (\emph{trace link}) en el modelo de trazabilidad.

%\begin{landscape}
\begin{figure}
\begin{center}
\includegraphics[width=0.8\textwidth]{img/Content2DomainWithTrace.png}
\end{center}
\caption{Incorporación de los (\emph{trace links}) en la generación de los modelos conceptuales de A-OOH.}
\label{fig:Content2DomainWithTrace}
\end{figure}
%\end{landscape}

\subsubsection{Análisis de Impacto en A-OOH}
\label{c1:analisisimpacto}

Los requisitos evolucionan constantemente a razón de la naturaleza dinámica de la Web. Debido a esto, es común encontrar inconsistencias entre los modelos conceptuales de la aplicación Web y los requisitos. Una de las ventajas ofrecidas por el soporte para trazabilidad en A-OOH es el de conocer las dependencias entre los elementos de los modelos conceptuales y los requisitos. Por tanto, es posible conocer los requisitos afectados debido a un cambio en alguno de los modelos conceptuales. 

Análisis de impacto, conocido también como (\emph{Change Impact Analysis}), es la tarea de identificar las consecuencias potenciales de un cambio o estimar qué es necesario modificar para llevar a cabo el cambio \cite{impact}, por ejemplo, una modificación en los modelos conceptuales de la aplicación Web o en la especificación de los requisitos. Comúnmente, el análisis de impacto se ha realizado de forma intuitiva por los diseñadores de la aplicación Web por medio de un análisis superficial del código y documentación de la aplicación. Esto quizá sea suficiente para aplicaciones Web no muy grandes, pero no es suficientes para aplicaciones Web sofisticadas. Asimismo, trabajos de investigación empírica como el presentado en \cite{Lindvall} y más recientemente en \cite{goeritzer2011usingImpactAna}, demuestran que incluso los desarrolladores más experimentados en la industria, deducen un análisis de impacto incompleto.

Para paliar esta limitante, se ha definido un algoritmo para analizar las dependencias entre los requisitos funcionales. El algoritmo analiza el modelo de requisitos para conocer las dependencias entre los requisitos funcionales además de saber qué requisitos no-funcionales se ven afectados (ver Capítulo \ref{c5}). De esta forma, a través del soporte para trazabilidad es posible conocer que otros elementos de los modelos conceptuales son afectados debido a un cambio en la aplicación Web. Finalmente, debido a que el modelo de requisitos es orientado a objetivos \cite{AguilarJUCS, Garrigos09}, el algoritmo puede mostrar al diseñador un camino alternativo en el cual se indique qué requisitos funcionales tienen que ser implementados para seguir cumpliento con el objetivo (\emph{Goal}). A continuación se presenta un ejemplo de la aplicación del algoritmo.

Supongamos que el cliente ha solicitado la implementación de una aplicación Web que permita la aplicación de encuestas \emph{on-line}. En primer lugar es necesario que el diseñador especifique los requisitos de la aplicación Web, para esta demostración, solo se ha definido el actor que representa a la aplicación Web (Figura \ref{fig:req1iccsa}). 

\begin{figure}
\begin{center}
\includegraphics[width=0.8\textwidth]{img/EjemploICCSA.png}
\end{center}
\caption{El modelo de requisitos de la aplicación \emph{``Survey WebApp''}.}
\label{fig:req1iccsa}
\end{figure}

El actor ``\emph{Survey WebApp}'' tiene que cumplir con el objetivo ``\emph{Survey be performed}'', para lograrlo dispone de dos vías, por medio de la aplicación de la encuesta pública ``\emph{Public survey}'' o la privada ``\emph{Private survey}'', ambos requisitos de navegación. Cada una de las vías necesita de uno o más requisitos para cumplirse, tal es el caso del requisito ``\emph{Private survey}'' debido a que necesita de los requisitos de navegación ``\emph{Make private survey}'' y ``\emph{View survey}'' así como del requisito de contenido ``\emph{Registered users}''. 

En este sentido, algunos de los requisitos afectan positiva o negativamente a las \emph{Softgoals}, por ejemplo, el requisito navegacional ``\emph{Private survey}'' afecta positivame a la \emph{Softgoal} ``\emph{Security}'' (encargada de la seguridad de la aplicación Web), pero también afecta de forma negativa a la \emph{Softgoal} ``\emph{Process Easier}'', la cual representa el nivel de simplicidad con que deberá realizarse el proceso de revisón utilizando la aplicación Web (usabilidad), por último, el requisito navegacional ``\emph{View Surveys}'' afecta de forma positiva a la \emph{Softgoal} ``\emph{Complete Info}'', es decir que si este requisito navegacional es implementado, el usuario de la aplicación Web podrá obtener información más detallada acerca del artículo asignado para su revisión.


El tipo de contribuciones que realizan los requisitos funcionales a las \emph{Softgoals} es relevante para la ejecución del algoritmo a razón de que son utilizadas para decidir qué requisitos funcionales será necesario implementar. En el ejemplo, solo los requisitos funcionales relacionados con el requisito de navegación ``\emph{Public survey}'' se encuentran implementados en los modelos conceptuales (Figura \ref{fig:req1iccsaIniciales}). 

\begin{figure}
\begin{center}
\includegraphics[width=0.8\textwidth]{img/EjemploICCSAReqIniciales.png}
\end{center}
\caption{Requisitos de la aplicación \emph{``Survey WebApp''} implementados inicialmente.}
\label{fig:req1iccsaIniciales}
\end{figure}

Ahora bien, supongamos el siguiente escenario: se presenta una solicitud de cambio en la estructura de la base de datos de la aplicación Web, por tal motivo, el diseñador Web necesita eliminar un elemento del modelo de dominio A-OOH, gracias al soporte para trazabilidad, es posible conocer el requisito afectado por la clase del modelo de dominio que ha sido eliminada, como puede verse en la Figura \ref{fig:req1iccsaIniciales}, la clase corresponde con el requisito navegacional ``\emph{Public survey}''. Por tanto, el objetivo ``\emph{Survey be performed}'' no se puede cumplir. Por tal motivo, es necesario conocer:

\begin{itemize}
	\item ¿Qué requisitos son afectados por este cambio en el modelo de requisitos?
	\item ¿Qué elementos de los modelos conceptuales son afectados?
\end{itemize}

Por último, es necesario encontrar un camino alternativo en el modelo de requisitos (si es que existe) para continuar cumpliendo con el objetivo ``\emph{Survey be performed}''.

El algoritmo inicia una vez que se han cumplido un conjunto de pre-condiciones, las cuales pueden consultarse con detalle en el Capítulo \ref{c5}. El primer paso del algoritmo consiste en realizar un listado de todos aquellos requisitos funcionales que se encuentren implementados o no (en este caso, reflejados en el modelo de dominio), y que además realicen alguna contribución positiva o negativa a cualquier \emph{Softgoal}, el listado quedará como lo muestra la Tabla \ref{tab:listaElementosIntencionales1}. El requisito afectado se muestra resaltado en negrita. Con el listado generado y el soporte para trazabilidad de A-OOH, es posible saber qué elementos del modelo conceptual de dominio resultan afectados por la eliminación del requisito navegacional ``\emph{Public survey}''.

\begin{table}
 \centering
%\tiny %\addtolength{\tabcolsep}{-5pt}
 \caption{La contribución de los requisitos funcionales a cada requisito no-funcional.}\label{tab:listaElementosIntencionales1}
\begin{tabular}{| l | c| c | c |}
\hline
\textbf{Requirements} &
\textbf{\emph{``Process easier''}} &
\textbf{\emph{``Complete info''}} &
\textbf{\emph{``Security''}}
\\
\hline
  \textbf{\emph{``Public Survey''}} & \textbf{Help} & \textbf{-} & \textbf{Hurt} \\
  \emph{``Make Survey''} & - & Break & - \\
  \emph{``Private Survey''} & Some- & - & Some+ \\
  \emph{``Send Survey''} & - & - & Some-\\
  \emph{``View Surveys''} & - & Make & -\\
  \emph{``Send Private Survey''} & - & - & Help \\
\hline
\end{tabular}
\end{table}

El siguiente paso consiste en determinar un camino alternativo para la satisfacción del objetivo de la aplicación (``\emph{Survey be performed}''). Por cada \emph{Softgoal} (requisito no-funcional) que recibe una contribución por parte del requisito a remover (Tabla \ref{tab:listaElementosIntencionales1}) es necesario buscar un requisito funcional no implementado del cual su contribución compense la eliminación del requisito a remover. En este caso, el requisito navegacional \emph{``Private Survey''} realiza dos contribuciones a las \emph{Softgoals} \emph{``Process easier''} y \emph{``Security''}, por lo tanto se puede implementar. Para poder determinar si el requisito se puede implementar o no, es necesario aplicar un conjunto de heurísticas, definidas previamente en el Capítulo \ref{c5}. El requisito navegacional \emph{``Private Survey''} se puede implementar gracias a las heurísticas número 2 y 3. Este paso es iterativo y finaliza cuando no hay más requisitos (no implementados) que realicen contribuciones a las \emph{Softgoals}. El paso finaliza cuando es detectado el requisito navegacional \emph{``Send Private Survey''}. 

Finalmente, es necesario aplicar una post-condición, la cual establece que si los requisitos a implementar (\emph{``Private Survey''} y \emph{``Send Private Survey''}) tienen uno o más requisitos funcionales asociados, deben ser implementadas de forma automática. Por tanto, los requisitos \emph{``View Surveys''} y \emph{``Registered Users''} deben de ser implementados. En la Figura \ref{fig:req2iccsa} se muestran los requisitos funcionales a implementar.


\begin{figure}
\begin{center}
\includegraphics[width=0.8\textwidth]{img/EjemploICCSAReqFinales.png}
\end{center}
\caption{Los nuevos requisitos a implementar en el modelo de dominio.}
\label{fig:req2iccsa}
\end{figure}


\subsubsection{Optimización de Requisitos No-Funcionales en Aplicaciones Web}
\label{c1:optimizacion}

Como se ha motivado anteriormente, las aplicaciones Web tienen una audiencia amplia y heterogénea \cite{aguilarDSDM, irene08}, debido a esto, el diseñador se enfrenta a una problemática muy particular: ¿cómo diseñar la aplicación optimizando el máximo número posible de requisitos no-funcionales, de tal forma que la aplicación Web sea capaz de satisfacer, en medida de lo posible, a la amplia y heterogénea audiencia?, una opción consiste en enriquecer a las metodologías de diseño para que sean capaces de asistir al diseñador en la etapa de requisitos, es decir, que permitan seleccionar distintas opciones de diseño en base a la audiencia de la aplicación Web. 

Por lo tanto, en A-OOH se ha implementado el algoritmo Optimización de Pareto \cite{Pareto1} para proveer al diseñador con un conjunto de alternativas de diseño basadas en la prioridad de los requisitos no-funcionales. La Optimización de Pareto, llamada así en honor de su introductor, Vilfredo Pareto, es un concepto de la economía con aplicación tanto en esa disciplina como en ciencias sociales e ingeniería \cite{KungPareto}. El concepto está relacionado con estudios de eficiencia económica y distribución del ingreso y establece como eficiente aquella situación en la cual se cumple que no es posible beneficiar a más individuos en un sistema sin perjudicar a otros. %Información más detallada sobre la implementación del algoritmo se encuentra en el Capítulo \ref{c6} de la tesis doctoral.

La Optimización de Pareto ha sido ampliamente aplicada en la ingeniería de \emph{software} \cite{Pareto3}, principalmente, en problemas en los que hay 2 o más objetivos, este tipo de problema es conocido como problema multi-objetivo (PMO) \cite{Pareto4}. En un problema de optimización, se trata de encontrar una solución que represente el valor óptimo para una función objetivo \cite{Pareto5}. Una característica de los PMO es que, como regla general, tienen un conjunto de soluciones, que inclusive puede ser infinito, y entonces los algoritmos deben describir lo mejor posible este conjunto. Por lo tanto, en este trabajo,  se han realizado algunas modificaciones que permiten obtener mejores representaciones de los conjuntos solución. Información más detallada se encuentra en el Capítulo \ref{c6} de la tesis doctoral. 

Para un mejor entendimiento de la propuesta presentada en este apartado, se han adaptado una serie de definiciones para la aplicación del algoritmo Óptimo de Pareto, estas son presentadas a continuación:

\newtheorem{definicion}{\rule{0.2in}{0.11in} {\rm Ejemplo }}

\newtheorem{defi}{{\sc \textbf{Definición.}}} 

\begin{defi}\label{Def1}
\textbf{Optimización de Pareto:} dado un conjunto de ubicaciones alternativas y un conjunto de individuos, la ubicación ``A'' es una optimización sobre la ubicación ``B'' si solo si ``A'' puede al menos, optimizar a un individuo mejor que ``B'', sin deteriorar a otro individuo'' \emph{\cite{Pareto2, Pareto1}}.  
\end{defi}

En la Definición \ref{Def1}, las ubicaciones alternativas corresponden con el estado del requisito funcional, es decir, si el requisito está o no está implementado. Por otra parte, el conjunto de individuos comprende al conjunto de requisitos funcionales utilizados por el algoritmo. Mientras que, optimizar a un individuo mejor que ``B'', significa maximizar a los requisitos no-funcionales. Finalmente, en la Definición \ref{Def1} la frase ``\emph{sin deteriorar a otro individuo}'' se refiere a no afectar negativamente a los requisitos no-funcionales. 

\begin{defi}\label{Def2}
\textbf{Configuración Óptima de Pareto:} es a aquella configuración que mejor satisfaga a un requisito no-funcional mientras satisface a los demás de igual o mejor forma. 
\end{defi}

\begin{defi}\label{Def3}
\textbf{Configuración:} una configuración esta formada por un conjunto de requisitos funcionales que pueden ser implementados en los modelos conceptuales de la aplicación Web.
\end{defi}

\begin{defi}\label{Def4}
\textbf{Frontera de Pareto:} es el espacio de solución constituido por el conjunto de soluciones óptimas de Pareto, es decir, las soluciones que no son dominadas por ninguna otra solución.
\end{defi}

\begin{defi}\label{Def5}
\textbf{Dominio entre Soluciones:} se dice que una solución no es dominada por otra solución cuando, en el espacio de solución, no existe ninguna otra que mejor satisfaga a un requisito no-funcional sin deteriorar a otro.
\end{defi}

El conjunto de soluciones óptimas de Pareto puede ser utilizado por el diseñador para la toma de decisiones, por ejemplo, cuando necesite seleccionar la configuración que mejor balancee la compensación entre los requisitos no-funcionales y cuando necesite considerar la maximización sobre un requisito no-funcional en particular.

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/ParetoApproach.png}
\end{center}
\caption{Propuesta para la optimización de requisitos no-funcioales en aplicaciones Web.}
\label{fig:ParetoApproach}
\end{figure}

La Figura \ref{fig:ParetoApproach} muestra los pasos definidos en la propuesta descrita en este apartado para la optimización de requisitos no-funcionales. En el primer paso, el \emph{stakeholder}, concretamente en el rol de diseñador, especificará los requisitos de la aplicación Web utilizando el marco de modelado orientado a objetivos \emph{i*}, así mismo, establecerá una lista de requisitos no-funcionales a priorizar. El segundo paso consiste en aplicar el algoritmo Optimización de Pareto, como resultado del algoritmo se obtendrá un conjunto de configuraciones. Finalmente, ln último paso consiste en la selección de la configuración que mejor satisfaga la lista de requisitos no-funcionales a priorizar. Es importante destacar que los requisitos no-funcionales son considerados \emph{Softgoals} en la propuesta para la especificación de requisitos, como se definió en la Sección \ref{especificacion}.

A continuación, se presenta un ejemplo conciso para ejemplificar paso a paso la aplicación de la propuesta para la optimización de requisitos \emph{Softgoals} en aplicaciones Web. El caso de estudio es acerca de una aplicación Web para la gestión de conferencias (\emph{Conference Management System})\footnote{La especificación completa del caso de estudio se encuentra en \url{http://users.dsic.upv.es/~west/iwwost01}}. El propósito de la aplicación Web es brindar soporte al proceso de envío, evaluación y selección de los artículos para una conferencia. La Figura \ref{fig:CasoEstudioWISM}, muestra la especificación de requisitos de la aplicación Web (modelo de requisitos \emph{i*}). El objetivo de la aplicación Web consiste en ``\emph{Process of review of papers be selected}'', para satisfacer el objetivo, es necesario la implementación de alguno de los requisitos navegacionales ``\emph{Blind review process}'' y ``\emph{Normal review process}''. En este ejemplo el objetivo es logrado a través del requisito navegacional ``\emph{Blind review process}''. Para una explicación detallada del ejemplo se recomienda al lector consultar el Capítulo \ref{c6} de la tesis doctoral.

En la especificación de requisitos, también se puede observar que algunos requisitos necesitan de otros para poder cumplir con su función, tal es el caso del requisito navegacional ``\emph{Review paper}'' el cual necesita del requisito de servicio ``\emph{Submit review}''. Además, algunos requisitos afectan de forma positiva o negativa a algunas \emph{Softgoals}, por ejemplo, el requisito de servicio ``\emph{Download paper without author's name}'' afecta de forma positiva a la \emph{Softgoal} ``\emph{Privacy be maximized}'' y de forma negativa a ``\emph{Obtain more complete info}''. Las contribuciones de los requisitos funcionales a las \emph{Softgoals} pueden verse en la Tabla \ref{tab:contribuciones}.

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/CasoEstudioWISM.png}
\end{center}
\caption{Especificación de requisitos de la aplicación Web para la gestión de conferencias.}
\label{fig:CasoEstudioWISM}
\end{figure}

\begin{table}
 \centering
 \small
 \caption{Tipos de contribuciones.}\label{tab:contribuciones}
\begin{tabular}{|l | c |}
\hline
\textbf{Contribución} & \textbf{Tipo de Contribución} \\
\hline
Positiva& Help \\
Positiva de fuerza desconocida & Some + \\
Negativa & Hurt \\
Negativa de fuerza desconocida & Some - \\
Negativa suficiente para no satisfacer una \emph{Softgoal}& Break \\
Positiva suficiente para satisfacer una \emph{Softgoal} & Make \\
\hline
\end{tabular}
\end{table}

Una vez especificados los requisitos de la aplicación Web, es necesario elaborar una lista que contenga a los requisitos (implementados o no) que realicen algún tipo de contribución a alguna \emph{Softgoal}. La Tabla \ref{tab:listaElementosIntencionales}, muestra una lista de requisitos y el tipo de contribución (Tabla \ref{tab:contribuciones}) hacia las \emph{Softgoals}, en donde: S1 se refiere a la \emph{Softgoal} \emph{``Be fair in review''}, la \emph{Softgoal} representa en el modelo de requisitos que el proceso de revisión en la aplicación para la gestión de conferencias debe de ser imparcial, la \emph{Softgoal} S2 corresponde a \emph{``Review process easier''} y se refiere a que el proceso de revisión debe de ser lo más simple posible de realizar gracias a que se llevará a cabo por medio de la aplicación Web, la \emph{Softgoal} S3 llamada \emph{``Accurate review process''} es utilizada para indicar que el proceso de revisión debe de ser lo más preciso posible, S4 se refiere a la \emph{Softgoal} \emph{``Privacy be maximized''} para indicar que en la aplicación Web la seguridad debe de ser maximizada cuando se realicen ciertos requisitos funcionales en particular, la \emph{Softgoal} S5 nombrada \emph{``Avoid possible conflicts of interest''}, permite representar la ética del usuario de la aplicación Web debido a que este deberá ser capaz de evitar conflictos de interés al momento de realizar la revisión del artículo asignado y la \emph{Softgoal} S6, \emph{``Obtain more complete info''} la cual representa que al realizarse un proceso de revisión normal, el usuario de la apliación obtendrá información más detallada sobre los autores del artículo que le ha sido asignado.

\begin{table}
 \centering
\small %\addtolength{\tabcolsep}{-5pt}
 \caption{Las contribuciones de los requisitos hacia las \emph{Softgoals}.}\label{tab:listaElementosIntencionales}
\begin{tabular}{| l | c| c | c | c | c | c |}
\hline
\textbf{Requisitos} &
\textbf{\emph{``S1''}} &
\textbf{\emph{``S2''}} &
\textbf{\emph{``S3''}} &
\textbf{\emph{``S4''}} &
\textbf{\emph{``S5''}} &
\textbf{\emph{``S6''}}
\\
\hline
  \emph{``Blind review process''} & Help & Break & Hurt & Help & - & -\\
  \textbf{\emph{``Download papers without authors' name''}} & \textbf{-} & \textbf{-} & \textbf{-} & \textbf{-} & \textbf{Help} & \textbf{Some -}\\
  \emph{``Normal review process''} & Some - & Make & Help & - & - & -\\
  \emph{``Download paper with author's name''} & - & - & - & Hurt & Some - & Help\\
  \emph{``View review process status''} & - & - & - & - & - & Help\\
\hline
\end{tabular}
\end{table}


A continuación, es necesario almacenar cada configuración posible de los requisitos listados en la Tabla \ref{tab:listaElementosIntencionales}, en donde: la variable ``I'' representa el estado ``implementado'' y la variable ``N'' el estado ``no implementado''. Por lo tanto, tenemos 32 posibles configuraciones (Tabla \ref{tab:front}, columnas 1 y 2).

Además, es necesario asignar un peso a cada tipo de contribución, para esto, deben de asignarse por cada tipo el peso(W):  w= +1 si el tipo de contribución es  ``\emph{Help}'',  w= -1 si es ``\emph{Hurt}'', w= +2 para el tipo ``\emph{Some +}'' , w= -2 para ``\emph{Some -}'', w= +4 si es del tipo ``\emph{Make}'' y w= -4 para el tipo ``\emph{Break}''. 

Es importante mencionar que el valor del umbral de la contribución depende de los fundamentos del marco de modelado \emph{i*}, por ejemplo, teniendo en cuenta que la contribución del tipo ``\emph{Make}'' es el valor positivo más fuerte que sirve para al satisfacción de una \emph{Goal} o \emph{Softgoal}, se decidió asignarle el valor numérico 4. Esta forma de proceder continúa en proceso de estudio con la idea de tener una distribución de los valores numéricos lo más confiable posible, por esta razón se están realizando una serie de experimentos actualmente.

%Por ejemplo, dada la matriz (\ref{mt:matriz}), tenemos que, para la fila 3 (requisito ``\emph{Normal review process}'') y columna 2 (\emph{Softgoal ``Review process easier''}) la matriz muestra '+4', es decir una contribución del tipo ``\emph{Make}'' si el requisito es implementado.

\begin{equation}
\small
M= 
\begin{pmatrix}
  \hfill {\color {black} +1} & \hfill {\color {red} -4} & \hfill{\color {red} -1} & {\color {black} 0} & \hfill {\color {black} +1} & {\color {black} 0}\\
  {\color {black} 0} & {\color {black} 0} & {\color {black} 0} & \hfill {\color {black} +1} & {\color {black} 0} & \hfill{\color {red} -2} \\
  \hfill{\color {red} -2} & \hfill {\color {black} +4} & \hfill {\color {black} +1} & {\color {black} 0} & {\color {black} 0} & {\color {black} 0} \\
  {\color {black} 0} & {\color {black} 0} & {\color {black} 0} & \hfill{\color {red} -2} & \hfill{\color {red} -1} & \hfill {\color {black} +1}\\
  {\color {black} 0} & {\color {black} 0} & {\color {black} 0} & {\color {black} 0} & {\color {black} 0} & \hfill {\color {black} +1} \\
\label{mt:matriz}
\end{pmatrix}
\end{equation}


\begin{table}%[!ht]
 \centering
\small%\tiny %\addtolength{\tabcolsep}{-5pt}
 \caption{Lista de \emph{Softgoals}.}\label{tab:prioridad}
\begin{tabular}{| c | c|}
\hline
\textbf{Prioridad} & \textbf{Softgoal}
\\
\hline
\textbf{1} & \emph{``S4.- Privacy be maximized''}  \\
\textbf{2} & \emph{``S2.- Review process easier''} \\
\textbf{3} & \emph{``S3.- Accurate review process''} \\
\textbf{4} & \emph{``S1.- Be fair in review''} \\
\textbf{5} & \emph{``S5.- Avoid possible conflicts os interest''}\\
\textbf{6} & \emph{``S6.- Obtain more complete info''}  \\
\hline
\end{tabular}
\end{table}

Con los pesos establecidos, el siguiente paso consiste en crear una matriz para calcular los valores númericos asociados cada configuración (Tabla \ref{tab:front}, columnas 7 a 12), por ejemplo para la configuración X25, si el requisito R1 \emph{``Blind review process''} no es implementado, tenemos que la \emph{Softgoal} \emph{``Be fair in review''} será afectada (-2). Por último, se calcula si la configuración es Frontera de Pareto (Tabla \ref{tab:front}, columnas 13), para hacerlo, se deben comparar cada una de las configuraciones indicando si es que existe una que sea mejor que otra, por ejemplo, la configuración X3 está en la Frontera de Pareto por que es mejor que las configuraciones X1 y X2 debido a que maximiza al menos a un individuo, es decir, maximiza a la \emph{Softgoal} 5 \emph{``Avoid possible conflicts of interest''}.


\begin{table}[!ht]
 \centering
\small%\tiny %\addtolength{\tabcolsep}{-5pt}
 \caption{The posible requirements to implement or not for the softgoal tradeoff.}\label{tab:front}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
\textbf{Configuración} & \textbf{R1} & \textbf{R2} & \textbf{R3} & \textbf{R4} & \textbf{R5} & \textbf{F(S1)} & \textbf{F(S2)} & \textbf{F(S3)} & \textbf{F(S4)} & \textbf{F(S5)} & \textbf{F(S6)} & \textbf{Pareto front}
\\
\hline
\textbf{X1} & I & I & I & I & I & -1 & 0 & 0 & -1 & 0 & 0 & No\\ %\rowcolor[rgb]{0.8,0.8,0.8}
\textbf{X2} & I & I & I & I & N & -1 & 0 & 0 & -1 & 0 & -1 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X3} & I & I & I & N & I & -1 & 0 & 0 & 1 & 1 & -1 & Yes\\
\textbf{X4} & I & I & I & N & N & -1 & 0 & 0 & 1 & 1 & -2 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X5} & I & I & N & I & I & 1 & -4 & -1 & -1 & 0 & 0 & Yes\\
\textbf{X6} & I & I & N & I & N & 1 & -4 & -1 & -1 & 0 & -1 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X7} & I & I & N & N & I & 1 & -4 & -1 & 1 & 1 & -1 & Yes\\
\textbf{X8} & I & I & N & N & N & 1 & -4 & -1 & 1 & 1 & -2 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X9} & I & N & I & I & I & -1 & 0 & 0 & -2 & 0 & 2 & Yes\\
\textbf{X10} & I & N & I & I & N & -1 & 0 & 0 & -2 & 0 & 1 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X11} & I & N & I & N & I & -1 & 0 & 0 & 0 & 1 & 1 & Yes\\
\textbf{X12} & I & N & I & N & N & -1 & 0 & 0 & 0 & 1 & 0 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X13} & I & N & N & I & I & 1 & -4 & -1 & -2 & 0 & 2 & Yes\\
\textbf{X14} & I & N & N & I & N & 1 & -4 & -1 & -2 & 0 & 1 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X15} & I & N & N & N & I & 1 & -4 & -1 & 0 & 1 & 1 & Yes\\
\textbf{X16} & I & N & N & N & N & 1 & -4 & -1 & 0 & 1 & 0 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X17} & N & I & I & I & I & -2 & 4 & 1 & -1 & -1 & 0 & Yes\\
\textbf{X18} & N & I & I & I & N & -2 & 4 & 1 & -1 & -1 & -1 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X19} & N & I & I & N & I & -2 & 4 & 1 & 1 & 0 & -1 & Yes\\
\textbf{X20} & N & I & I & N & N & -2 & 4 & 1 & 1 & 0 & -2 & No\\
\textbf{X21} & N & I & N & I & I & 0 & 0 & 0 & -1 & -1 & 0 & No\\
\textbf{X22} & N & I & N & I & N & 0 & 0 & 0 & -1 & -1 & -1 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X23} & N & I & N & N & I & 0 & 0 & 0 & 1 & 0 & -1 & Yes\\
\textbf{X24} & N & I & N & N & N & 0 & 0 & 0 & 1 & 0 & -2 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X25} & N & N & I & I & I & -2 & 4 & 1 & -2 & -1 & 2 & Yes\\
\textbf{X26} & N & N & I & I & N & -2 & 4 & 1 & -2 & -1 & 1 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X27} & N & N & I & N & I & -2 & 4 & 1 & 0 & 0 & 1 & Yes\\
\textbf{X28} & N & N & I & N & N & -2 & 4 & 1 & 0 & 0 & 0 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X29} & N & N & N & I & I & 0 & 0 & 0 & -2 & -1 & 2 & Yes\\
\textbf{X30} & N & N & N & I & N & 0 & 0 & 0 & -2 & -1 & 1 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X31} & N & N & N & N & I & 0 & 0 & 0 & 0 & 0 & 1 & Yes\\
\textbf{X32} & N & N & N & N & N & 0 & 0 & 0 & 0 & 0 & 0 &  No\\
\hline
\end{tabular}
\end{table}


Finalmente, el último paso consiste, aparte de maximizar las \emph{Softgoals}, continuar cumpliendo con el objetivo establecido en el modelo de requisitos (\emph{``Process of review papers be selected''}). Para esto, es necesario crear una lista de \emph{Softgoals} ordenadas por prioridad (Tabla \ref{tab:prioridad}). En base a la lista, se debe de seleccionar de la Tabla \ref{tab:front} las configuraciones que además de estar en la Frontera de Pareto cumplen con el objetivo, y de esta forma escoger la configuración que maximice las \emph{Softgoals}.


Para este ejemplo, ``X3'', ``X7'' y ``X17'' cumplen con el objetivo, de las tres configuraciones, la configuración X3 es la mejor opción, porque de acuerdo con la lista (Tabla \ref{tab:prioridad}), ``S4'' y ``S2'' son las \emph{Softgoals} a priorizar, por tanto, la configuración ``X17'' maximiza ``S2'', sin embargo afecta negativamente a la \emph{Softgoal} 4 (Tabla \ref{tab:front}). En cambio, la configuración ``X3'' maximiza a la \emph{Softgoal} ``S4'' (1) y no afecta a la \emph{Softgoal} ``S2'' (0).


\section{Hacia la Gestión de Requisitos en las \emph{Rich Internet Applications}}
\label{c1:rias}

En la actualidad, las aplicaciones Web evolucionan constantemente, por ejemplo, se evolucionó de las páginas HTML\footnote{\emph{Hyper Text Markup Language}} estáticas al siguiente nivel en donde la mayor parte del contenido era generado dinámicamente a través de diversos sistemas y bases de datos. Conforme a esta evolución, se crearon las primeras metodologías para el desarrollo de aplicaciones Web, como OOHDM \cite{OOHDM1995}. Al continuar la evolución natural de las aplicaciones Web, se tomaron en cuenta factores importantes como la estética, el contenido, la funcionalidad y la personalización en las metodologías de desarrollo (UWE \cite{Koch02}, WebML \cite{WebML}, NDT \cite{NDT}, OOWS \cite{OOWS2001}, A-OOH  \cite{irene08}). 

Recientemente, las aplicaciones Web han experimentado cambios significativos relacionados con la tecnología de implementación, la distribución de la lógica de negocio entre el cliente y el servidor, la comunicación que se establece entre ambos así como las interfaces de usuario (UIs). Este tipo de aplicaciones Web recibe el nombre de RIAs (\emph{Rich Internet Applications}) y se caracterizan por ofrecer al usuario una serie de características muy similares a las de las aplicaciones de escritorio, así como la inclusión de contenido multimedia bajo demanda, la actualización de contenido dinámicamente, es decir, sin que la página Web vuelva a ser generada por completo tras una petición del usuario y la posibilidad de comunicación por medio del audio y video.  La Figura  \ref{fig:RiasDiagramaVenn}\footnote{Imagen tomada de \url{http://www.simonwhatley.co.uk/rich-internet-applications-a-background}} muestra un diagrama de Venn en donde se representa la combinación de tecnologías que han dado origen a las RIAs, por tanto se puede deducir fácilmente que las RIAs son una combinación de la tecnología y/o funcionalidad de las aplicaciones de escritorio, de las aplicaciones Web y de las tecnologías de comunicación (audio, video, Internet).


\begin{figure}
\begin{center}
\includegraphics[width=0.4\textwidth]{img/RiasDiagramaVenn.png}
\end{center}
\caption{Diagrama de Venn que ejemplifica las características de las RIAs.}
\label{fig:RiasDiagramaVenn}
\end{figure}


Sin embargo, la evolución de las aplicaciones Web a RIAs conlleva a una mayor complejidad en su desarrollo debido al nivel de funcionalidad e interactividad que ofrecen al usuario. Por lo tanto, son más difíciles de diseñar e implementar que las aplicaciones Web 1.0. Por esta razón, las metodologías para el desarrollo de aplicaciones Web han sido objeto de mejoras (adaptaciones en algunos casos) y han surgido nuevas aproximaciones específicamente para el desarrollo de RIAs \cite{Preciado}. Dentro del grupo de aproximaciones que han sido extendidas para el soporte de RIAs encontramos a OOHDM \cite{OOHDMRIA}, OOH con la extención OOH4RIAs \cite{OOH4RIAMethod}, UWE con las extensiones UWE-Patterns \cite{UWEpatterns4RIA}, UWE-R \cite{UWER} y UWE-RUX \cite{RUXMethod}, WebML \cite{Bozzon2008, Bozzon2006} y OOWS  \cite{Valverde2010}. Por otra parte, dentro del grupo de aproximaciones creadas exclusivamente para el desarrollo de RIAS encontramos a RUX-Model \cite{Preciado2008}, \emph{Internet Aplication Modeling Language} \cite{IAML} y ADRIA \cite{ADRIA2,ADRIA1}, para información más detallada sobre las aproximaciones tradicionales y las de nueva creación el lector puede consultar el Apéndice \ref{a2}. La idea principal de las aproximaciones es brindar soporte a las características particulares de las RIAs, pero la mayoría de las metodologías se han enfocado principalmente en cuestiones de presentación \cite{RUXMethod, Preciado2007} y en capacidades de interacción \cite{OOH4RIAMethod} descuidando la etapa de análisis y especificación de requisitos. Esto es una desventaja muy importante a considerar, debido a que el diseñador tiene que lidiar con los requisitos de la Web 1.0, como lo es la navegación más los requisitos específicos de las RIAs, tales como, la capacidad de respuesta o la reducción del ancho de banda \cite{ReqForRIA}. 

Además, el diseñador debe de considerar la distribución de los requisitos funcionales, es decir, si son implementados en el cliente o en el servidor y como es que la distribución afecta el cumplimiento de las \emph{Softgoals}. Por ejemplo, si se analiza la distribución de los requisitos funcionales entre el cliente y el servidor, se podrán tomar decisiones de diseño que favorezcan la reducción de la cantidad y frecuencia del tráfico entre el cliente y el servidor, lo que sin duda alguna resulta en un beneficio para la seguridad de la RIA. Por lo tanto, elegir dónde serán implementados los requisitos funcionales (cliente o servidor) es una decisión fundamental (más no trivial) para el correcto desempeño de la RIA.

En esta sección, se presenta una adaptación del trabajo presentado en la sección \ref{c1:optimizacion} (el trabajo se explica en detalle en el Capítulo \ref{c6} de la tesis) para asistir al diseñador al momento de decidir sobre la distribución de los requisitos funcionales de la aplicación Web entre el cliente y el servidor. Para esto, se han definido una serie de pasos los cuales pueden verse en la Figura \ref{fig:overview}. El primer paso consiste en la especificación de los requisitos por parte del diseñador y existen dos formas para llevarla a cabo, en la primera, el diseñador puede crear un modelo de requisitos RIA a partir de un modelo de requisitos para aplicaciones Web 1.0, la forma de hacerlo es especificar en el modelo de requisitos los requisitos particulares de las RIAs; la segunda forma, consiste en crear un modelo de requisitos desde cero, es decir, exclusivamente con los requisitos de las RIAs. El segundo paso es aplicar el algoritmo de Óptimo de Pareto para obtener el conjunto de configuraciones Cliente/Servidor. Por último, en el tercer paso el diseñador solo tendrá que seleccionar el modelo de requisitos final con el cuál podrá saber qué requisitos funcionales implementar en el servidor o en el cliente considerando la optimización de las \emph{Softgoals}. Para obtener información más detallada sobre la adaptación de la propuesta presentada en el Capítulo \ref{c6}, así como las definiciones y conceptos de esta sección consultar Apéndice \ref{a2} y Apéndice \ref{a3}.

A continuación, se presenta un caso de estudio para ejemplificar la propuesta presentada en este apartado de la tesis doctoral. El caso de estudio es acerca de una compañía de bioinformática, la cual tiene como objetivo ofrecer servicios en línea sobre el análisis del genóma humano. La aplicación Web permitirá al usuario subir la información sobre un gen, analizar la información y obtener reportes personalizados. El primer y único servicio disponible para el usuario será el reporte de enfermedades al que es vunerable el gen, para lograrlo, se comparará la información proporcionada por el usuario con la base de datos de genes de la compañía. La compañía, desea ofrecer una Web basada en RIA con la finalidad de ofrecer una aplicación Web lo suficientemente atractiva e interactiva para los usuarios. Para esto, el equipo de desarrollo de la compañía quiere estudiar y analizar los beneficios que se obtendrán de la distribución de los requisitos funcionales entre el servidor y el cliente, así como el impacto que tendrán en las \emph{Softgoals} para poder considerar asuntos relacionados a la seguridad de la información proporcionada por el usuario así como estudiar la compatibilidad cuando sea mostrada la información a los usuarions de la RIA. Para efectos demostrativos, en el caso de estudio nos enfocaremos en los requisitos necesarios para el reporte de enfermedades.

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/OverviewRIAs.png}
\end{center}
\caption{Visión general de la propuesta para el análisis de requisitos RIA.} \label{fig:overview}
\end{figure}


El primer paso consiste en la especificación del modelo de requisitos base para RIAs por parte del diseñador. En él, el diseñador deberá especificar los objetivos, los requisitos funcionales y las \emph{Softgoals} necesarias para modelar el reporte de enfermedades (Figura \ref{fig:baseRIA}).

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/EjemploRIAs.png}
\end{center}
\caption{Modelo de requisitos RIA base.} \label{fig:baseRIA}
\end{figure}

Debido a que aún no sabemos qué requisitos serán ubicados de lado del cliente o de lado del servidor, las contribuciones por parte de los requisitos a las \emph{Softgoals} son etiquetadas como ``\emph{unknown}''. En el particular caso de la \emph{Softgoal} ``Compatibilidad'', las contribuciones recibidas por parte de los requisitos quedan establecidas en este paso debido a que no dependen del lugar donde se implementará el requisito (cliente o servidor). Las contribuciones originadas en el requisito ``Proporcionar interfaz gráfica'' también son etiquetadas debido a que el requisito solo puede ser implementado del lado del cliente.

El segundo paso consiste en aplicar el algoritmo Óptimo de Pareto (Figura \ref{fig:overview}) para obtener el conjunto de configuraciones Cliente/Servidor. Para poder hacerlo, es necesario identificar a los requisitos que realizan contribuciones a las \emph{Softgoals}, no se deberá considerar el requisito ``Proporcionar interfaz gráfica'' por que, como lo mencionamos antes, solo es posible implementarlo del lado del cliente. La Tabla \ref{tab:softgoals-req} muestra los requisitos y \emph{Softgoals} a utilizar.

\begin{table}
 \centering
 \caption{\emph{Softgoals} y Requisitos detectados en el modelo de requisitos RIA base.}\label{tab:softgoals-req}
\begin{tabular}{|l | l |}
\hline
\textbf{\emph{Softgoals}} & \textbf{Requisitos} \\
\hline
S1.- Seguridad & R1.- Proporcionar variaciones por enfermedad \\
S2.- Tiempo de respuesta & R2.- Proporcionar enfermedad por variante \\
S3.- Compatibilidad & R3.- Proporcionar PDF \\
S4.- Ancho de banda limitado & R4.- Proporcionar documento en formato propietario \\
\hline
\end{tabular}
\end{table}

En seguida, es necesario calcular todas las posibles configuraciones Cliente/Servidor, en donde C representa si el requisito se implementará en el Cliente y S si se implementará en el Servidor, como puede verse en la Tabla \ref{tab:front}, de la columna 2 a la columna 5. Posteriormente, se deberán obtener dos matrices (Matriz Cliente (\ref{mt:matriz}) y Matriz Servidor (\ref{mt:matrizServidor})) las cuales representan la contribución de cada requisito a cada una de las \emph{softgoals}, por ejemplo, la fila 3 (requisito ``Proporcionar PDF''), columna 4 (\emph{softgoal} ``Tiempo de respuesta'') muestra +1 en la Matriz Cliente, por lo que es una contribución del tipo ``\emph{Help}'' si el requisito es implementado en el Cliente, en cambio, en la Matriz Servidor muestra -1, indicando una contribución del tipo ``\emph{Hurt}'' si el requisito se implementa en el Servidor. Con las matrices se calculará el resultado de las contribuciones de los requisitos a las \emph{Softgoals}, el cual es mostrado de la columna 6 a la columna 9 de la Tabla \ref{tab:front}. Por último, se indica si la configuración está o no en la Frontera de Pareto (última columna).

\begin{equation}
%\tiny
M_{i_j}^k = 
\begin{pmatrix}
  \hfill {\color {red} -1} & \hfill {\color {black} +1} & \hfill{\color {black} 0} & {\color {black} 0} \\
  \hfill {\color {red} -1} & \hfill {\color {black} +1} & \hfill{\color {black} 0} & {\color {black} 0} \\
  \hfill {\color {red} -1} & \hfill {\color {black} +1} & \hfill{\color {black} +1} & {\color {red} -1} \\
  \hfill {\color {red} -1} & \hfill {\color {black} +1} & \hfill{\color {red} -1} & {\color {red} -1} \\
\label{mt:matriz}
\end{pmatrix}
\end{equation}

\begin{equation}
%\tiny
M_{i_j}^k = 
\begin{pmatrix}
  \hfill {\color {black} +1} & \hfill {\color {red} -1} & \hfill{\color {black} 0} & {\color {black} 0} \\
  \hfill {\color {black} +1} & \hfill {\color {red} -1} & \hfill{\color {black} 0} & {\color {black} 0} \\
  \hfill {\color {black} +1} & \hfill {\color {red} -1} & \hfill{\color {black} +1} & {\color {black} +1} \\
  \hfill {\color {black} +1} & \hfill {\color {red} -1} & \hfill{\color {red} -1} & {\color {black} +1} \\
\label{mt:matrizServidor}
\end{pmatrix}
\end{equation}
En la Tabla \ref{tab:front}, las filas de color gris son la Frontera de Pareto. Finalmente, en el tercer paso (ver Figura \ref{fig:overview}), el diseñador puede seleccionar de la Frontera de Pareto la configuración que mejor satisfaga las necesidades del \emph{stakeholder}, es decir, considerando a las \emph{Softgoals} de mayor interés. Por mencionar un ejemplo, tenemos que la configuración X1 (Tabla \ref{tab:front}) es la mejor opción si la \emph{Softgoal} ``Tiempo de respuesta'' es la prioridad, en la solución cada requisito será implementado de lado del Cliente y, de acuerdo con el resultado positivo de la columna 10 ($\Sigma$), las \emph{Softgoals} restantes serán maximizadas o permanecerán igual, es decir, no serán afectadas negativamente. Por otro lado, la mejor opción respecto a la \emph{softgoal} ``Seguridad'' es la configuración X16 (Figura \ref{fig:X16}), de acuerdo con $\Sigma$ (-2), mejorar la seguridad afectará negativamente en algunas de las \emph{Softgoals}. 



\begin{table}
\centering
%\tiny%\addtolength{\tabcolsep}{-5pt}
 \caption{La posible distribución de los requisitos entre el servidor y el cliente a través de la compensación de las \emph{softgoals}.}\label{tab:front}
    \begin{tabular}{|c|cccc|cccc|c|c|}
        \hline
        \textbf{Configuración}          & \textbf{R1} & \textbf{R2} & \textbf{R3} & \textbf{R4} & \textbf{F(S1)} & \textbf{F(S2)} & \textbf{F(S3)} & \textbf{F(S4)} & \textbf{$\Sigma$} & \textbf{Frontera de Pareto} \\ \hline 
        \rowcolor[rgb]{0.8,0.8,0.8}X1  & C          & C          & C          & C          & -4            & +4            & 0             & +2            & +2               & Si                         \\ \hline
        X2                             & C          & C          & C          & S          & -2            & +2            & 0             & 0             & 0                & No debido a X5             \\ \hline
        X3                             & C          & C          & S          & C          & -2            & +2            & 0             & 0             & 0                & No debido a X6             \\ \hline
        X4                             & C          & C          & S          & S          & 0             & 0             & 0             & -2            & -2               & No debido a X13            \\ \hline
        \rowcolor[rgb]{0.8,0.8,0.8}X5  & C          & S          & C          & C          & -2            & +2            & 0             & +2            & +2               & Si                         \\ \hline
        \rowcolor[rgb]{0.8,0.8,0.8}X6  & C          & S          & C          & S          & 0             & 0             & 0             & 0             & 0                & Si                         \\ \hline
        \rowcolor[rgb]{0.9,0.9,0.9}X7  & C          & S          & S          & C          & 0             & 0             & 0             & 0             & 0                & Si (como X6)               \\ \hline
        X8                             & C          & S          & S          & S          & +2            & -2            & 0             & -2            & -2               & No debido a X14            \\ \hline
        \rowcolor[rgb]{0.9,0.9,0.9}X9  & S          & C          & C          & C          & -2            & +2            & 0             & +2            & +2               & Si (como X5)               \\ \hline
        \rowcolor[rgb]{0.9,0.9,0.9}X10 & S          & C          & C          & S          & 0             & 0             & 0             & 0             & 0                & Si (como X6)               \\ \hline
        \rowcolor[rgb]{0.9,0.9,0.9}X11 & S          & C          & S          & C          & 0             & 0             & 0             & 0             & 0                & Si (como X6)               \\ \hline
        X12                            & S          & C          & S          & S          & +2            & -2            & 0             & -2            & -2               & No debido a X14            \\ \hline
        \rowcolor[rgb]{0.8,0.8,0.8}X13 & S          & S          & C          & C          & 0             & 0             & 0             & +2            & +2               & Si                         \\ \hline
        \rowcolor[rgb]{0.8,0.8,0.8}X14 & S          & S          & C          & S          & +2            & -2            & 0             & 0             & 0                & Si                         \\ \hline
        \rowcolor[rgb]{0.9,0.9,0.9}X15 & S          & S          & S          & C          & +2            & -2            & 0             & 0             & 0                & Si (como X14)              \\ \hline
        \rowcolor[rgb]{0.8,0.8,0.8}X16 & S          & S          & S          & S          & +4            & -4            & 0             & -2            & -2               & Si                         \\
        \hline
    \end{tabular}
\end{table}

El resto de configuraciones de la Frontera de Pareto (Tabla \ref{tab:front}) son configuraciones intermedias que estarán disponibles para que el diseñador pueda seleccionarlas de acuerdo a la compensación de las \emph{Softgoals} que necesite, por ejemplo, las configuraciones X6 y X14, ambas tienen $\Sigma$ = 0, por lo tanto, todas las \emph{Softgoals} están balanceadas. En la configuración X14, los requisitos R1, R2 y R4 son ubicados en el servidor y R2 en el cliente, la solución quiza proporcione una buena compensación en caso de que la seguridad sea una prioridad por parte del \emph{stakeholder}, pero no se mejorarán el resto de las \emph{Softgoals}, incluso, la \emph{Softgoal} `` Tiempo de respuesta'' será afectada negativamente.



\begin{landscape}	
	\begin{figure}
\begin{center}
%\includegraphics[width=1.5\textwidth]{img/X16.png}
\includegraphics[width=18.5cm,height=12.5cm]{img/X16.png}
\end{center}
\caption{Configuración X16: distribución de los requisitos entre el cliente y el servidor.} \label{fig:X16}
\end{figure}
\end{landscape}
	


\section{Implementación}
\label{c1:implementation}

Este apartado aborda los objetivos especificos planteados en la investigación asociada a la tesis doctoral. Los objetivos están descritos en la sección \ref{c1s1}. A continuación, se puntualiza cómo es que los objetivos han sido satisfechos a través de cada uno de los apartados establecidos en esta sección.

\begin{itemize}
	\item \textbf{\textit{Sección \ref{subseccioneditor}:}} ``Editor Gráfico para la Especificación de Requisitos Web (\emph{WebREd})''. En este apartado se explica la implementación de un editor gráfico para el análisis y especificación de requisitos por medio del marco de modelado orientado a objetivos \emph{i*}. Por lo tanto, se cumplen los objetivos especificos 1 y 2 (Sección \ref{c1s1}). Con el editor gráfico, se establecen mecanismos para la comprensión de los objetivos de negocio, y por medio del editor, los \emph{stakeholders} podrán razonar sobre ellos. Cabe destacar que los mecanismos están integrados dentro de una etapa de análisis de requisitos orientada a objetivos (Sección \ref{modelos} y Capítulo \ref{c4}), por tanto, brindan soporte para representar las expectativas reales de los \emph{stakeholders} de la aplicación Web.
	
	
\item \textbf{\textit{Sección \ref{imp:transformaciones}:}} ``Transformaciones Modelo a Modelo''. La sección permite satisfacer el objetivo 3 de la tesis doctoral, gracias a que por medio de las transformaciones modelo a modelo es posible la generación de las estructuras de los modelos conceptuales de la aplicación Web, que posteriormente, deberán ser completados por el diseñador. Por lo tanto, la sección \ref{imp:transformaciones} ofrece un alto grado de automatización en el desarrollo de aplicaciones Web por medio de un conjunto de transformaciones y con esto brinda soporte a la generación de código. Para más información consultar los artículos listados en la sección \ref{otraspub} y el Capítulo \ref{c4} de la tesis doctoral.

\item \textbf{\textit{Sección \ref{imp:trazabilidad}:}} ``Trazabilidad de Requisitos''. La sección proporciona el soporte necesario para satisfacer el objetivo especifico 4 de la sección \ref{c1s1} de la tesis. Por medio de las transformaciones modelo a modelo es posible ofrecer al diseñador soporte para trazabilidad de requisitos. Para más información consultar los artículos listados en la sección \ref{otraspub} y el Capítulo \ref{c5} de la tesis doctoral.

\item \textbf{\textit{Sección \ref{imp:pareto}:}} ``Optimización de Pareto''. La implementación que complementa la tesis doctoral cumple con el objetivo 5 de la sección \ref{c1s1}. Básicamente, el apartado \ref{imp:pareto} asiste al diseñador de la aplicación Web al momento de la selección de los requisitos funcionales a implementar a través de alternativas de diseño que consideren el balance y maximización de los requisitos no-funcionales. Para más información consultar el Capítulo \ref{c6} y el Apéndice \ref{a3} de la tesis.

\end{itemize}
   
Por otra parte, la propuesta presentada en la tesis doctoral ha seguido un proceso de desarrollo basado en MDA. Por lo tanto, para llevar a cabo la implementació ha sido necesaria combinación de un conjunto de tecnologías MDD entre las que destacan (i) la plataforma de desarrollo \emph{Eclipse}~\cite{ECLIPSE}, (ii) la tecnología EMF (\emph{Eclipse Modeling Framework}) \cite{EMF} y GMF (\emph{Graphical Modeling Framework}) \cite{GMF} y (iii) el lenguaje para transformaciones entre modelos ATL (\emph{Atlas Transformation Language}) \cite{ATL}. Cada una de las tecnologías utilizadas son descritas a continuación.



%La propuesta definida en esta tesis doctoral se ha implementado en la plataforma de desarrollo \emph{Eclipse}~\cite{ECLIPSE} utilizando tecnología EMF (\emph{Eclipse Modeling Framework}) (CITA) y GMF (\emph{Graphical Modeling Framework}) (CITA). \emph{Eclipse} puede extenderse por medio de \emph{plugins} con el fin de añadir más características y nuevas funcionalidades. Se ha desarrollado un \emph{plugin} que da soporte a cada parte de la propuesta. Este nuevo plugin contiene los siguientes módulos:

\begin{itemize}
   \item \textbf{\emph{Eclipse}}. Es un entorno de desarrollo integrado (\emph{Integrated Development Enviroment}, IDE) de código abierto multiplataforma, fue desarrollado originalmente por IBM\footnote{\url{http://www-01.ibm.com/software/rational/eclipse/}}. \emph{Eclipse} es ahora desarrollado por la Fundación \emph{Eclipse}, una organización independiente sin ánimo de lucro que fomenta una comunidad de código abierto. La característica principal del IDE es que es  una plataforma de programación utilizada para crear entornos integrados de desarrollo que puede ser extendida por medio de \emph{plugins} con el fin de añadir más características y nuevas funcionalidades. 
   
	\item \textbf{\emph{Eclipse Modeling Framework (EMF)}}. Es un marco de trabajo para modelado que ofrece facilidad de generación de código para construir herramientas y otras aplicaciones basadas en un modelo de datos estructurado. Desde una especificación del modelo descrita en XMI (XML de Intercambio de Metadatos), \emph{EMF} suministra herramientas y soporte en tiempo de ejecución para producir un conjunto de clases Java para el modelo, un conjunto de clases del tipo \emph{Adapter} que permiten visualización y edición basándose en comandos del modelo, y un editor básico. Los modelos pueden ser especificados usando notación Java, documentos XML, o herramientas de modelado como \emph{Rational Rose}\footnote{http://www-01.ibm.com/software/awdtools/developer/rose/}, y después ser importados a \emph{EMF}. Lo más importante de todo, \emph{EMF} suministra las bases para la interoperabilidad con otras herramientas y aplicaciones basadas en \emph{EMF}. Dentro de \emph{EMF} encontramos un metamodelo para describir modelos llamado Ecore, este metamodelo incluye soporte en tiempo de ejecución para los modelos además de notificación de cambios.
	
	\item \textbf{\emph{Graphical Modeling Framework (GMF)}}. Es un marco de trabajo que permite el desarrollo de editores gráficos. GMF combina EMF y GEF (\emph{Graphical Editing Framework}) para el desarrollo de editores gráficos \textit{ad-hoc}. De tal forma que, los elementos creados con el editor gráfico, son una representación visual de cada concepto especificado en el metamodelo.
	
	\item \textbf{\emph{Atlas Transformation Language (ATL)}}. Es un lenguaje de transformación de modelos basado en los estándares del
OMG \cite{OMG} y OCL 2.0 \cite{OCL}. ATL es un lenguaje declarativo e imperativo (híbrido) que permite la transformación entre modelos (M2M). Las construcciones declarativas son la opción preferida para escribir las transformaciones debido a que permiten expresar correspondencias, entre los elementos del modelo fuente y del modelo destino a partir de una serie de composiciones de reglas. Las construcciones imperativas proporcionan constructores para facilitar la especificación de correspondencias que de forma declarativa serían más complejas de implementar.

\item \textbf{\emph{Xpand}}. Es un lenguaje especializado en la generación de código a partir de modelos EMF \cite{Xpand}. Xpand ofrece la posibilidad de escribir completas librerias de funciones para la lectura de modelos EMF y permite la utilización de las librerias de funciones desde código Java \cite{Java} o expresiones Xtend.
     \item \textbf{\emph{Java}}. Es un lenguaje de programación orientado a objetos, diseñado principalmente para tener el mínimo de dependencia del sistema operativo para su utilización. Actualmente, Java es uno de los lenguajes de programación mías populares \cite{Java}.
\end{itemize}

Finalmente, en el apartado \ref{imp:casoestudio} de esta sección se presenta un caso de estudio para ejemplificar la aplicabilidad de nuestra propuesta. En el caso de estudio, se detalla la especificación de requisitos Web por medio del marco de modelado \emph{i*}, el soporte para trazabilidad de requisitos y la selección de las distintas alternativas de implementación de los requisitos funcionales mediante la optimización de las \emph{Softgoals}.

\subsection{Editor Gráfico para la Especificación de Requisitos Web (\emph{WebREd})}\label{subseccioneditor}

En este apartado son implementados los conceptos (sintaxis abstracta) del marco de modelado \emph{i*} y la clasificación de requisitos presentada en el Capítulo \ref{especificacion} de la tesis para proveer al diseñador con un editor gráfico para la especificación de requisitos Web. Como se mencionó anteriormente, la propuesta presentada en la tesis doctoral se encuentra alineada con MDA, por lo tanto, el editor WebREd corresponde al modelo independiente de computación (CIM). Concretamente, el metamodelo de requisitos implementado en la tesis doctoral ha sido extendido para incorporar los tipos de requisitos de \emph{i*} y la clasificación presentada en la sección \ref{especificacion}. La Figura \ref{fig:SeccionRequisitosWebMetamodelo} muestra una captura de pantalla donde puede apreciarse la implementación del metamodelo en \emph{Eclipse}. La sintáxis concreta del metamodelo para requisitos Web se ha implementado para desarrollar un editor gráfico (Figura \ref{fig:herramienta}) por medio de la tecnología GMF. 

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/Herramienta.png}
\end{center}
\caption{Editor WebREd para la especificación de requisitos Web con \emph{i*}.}
\label{fig:herramienta}
\end{figure}

El editor (Figura \ref{fig:herramienta}) WebREd (\emph{Web Requirements Editor}) brinda al diseñador de la aplicación Web una interfaz gráfica para especificar en un diagrama los requisitos funcionales y las \emph{Softgoals} de la aplicación Web. WebREd permite la creación, modificación y actualización de la especificación de requisitos Web (diagramas). Además, cada una de las propiedades de los elementos del marco de modelado \emph{i*} pueden ser modificadas seleccionando cada elemento en la vista de propiedades (Figura \ref{fig:PropViewWebREd}). 

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/PropViewWebREd.png}
\end{center}
\caption{Vista de propiedades del editor WebREd.}
\label{fig:PropViewWebREd}
\end{figure}

Es importante destacar que además de poder especificar modelos de requisitos Web (\emph{Content}, \emph{Navigational}, \emph{Personalization}, \emph{Service} y \emph{Layout}), WebREd permite la creación de diagramas (modelos orientados a objetivos) comúnes de \emph{i*} gracias a que coloca a disposición del diseñador los elementos clásicos (\emph{Goal}, \emph{Task}, \emph{Resource} y \emph{Softgoal}) del marco de modelado \emph{i*} como puede verse en la Figura \ref{fig:paleta}, en donde se muestran los elementos que permiten la creación de cada elemento \emph{i*} realizando un \emph{drag and drop} de cada elemento sobre el diagrama. 


\begin{figure}
\begin{center}
\includegraphics[width=0.3\textwidth]{img/paleta.png}
\end{center}
\caption{Elementos para el diseño del modelo de requisitos Web con \emph{i*}.}
\label{fig:paleta}
\end{figure}


\subsection{Transformaciones Modelo a Modelo}\label{imp:transformaciones}

Con el fin de aprovechar cada una de las ventajas que ofrece la ingeniería dirigida por modelos y con esto automatizar el paso del CIM al PIM, se han desarrollado una serie de reglas de transformación definidas formalmente en el lenguaje QVT (sección \ref{reglas}). Con esta idea, las transformaciones deben de ser vistas desde una perspectiva de modelado como modelos de transformaciones \cite{bezivin2006model}. En la investigación asociada a la tesis doctoral, QVT se ha utilizado como metamodelo para formalizar las transformaciones modelo a modelo abstrayéndolas como modelos, con el fin de mejorar la comprensión del proceso de transformación. Sin embargo, una vez que las transformaciones han sido modeladas, necesitan implementarse. Como se ha mencionado anteriormente, se ha utilizado el lenguaje ATL para implementar cada una de las reglas definidas en la sección \ref{reglas} y de esta forma ejecutarlas con el fin de realizar el proceso de normalización de forma automática. Cabe destacar que utilizar ATL para implementar transformaciones QVT es factible debido a la alineación que existe entre la arquitectura de ambos de lenguajes \cite{jouault2006architectural}.

La Figura \ref{fig:Content2DomainClass} muestra el código ATL referente a la implementación de la regla \emph{Content2DomainClass} (descrita en detalle en la sección \ref{reglas}). La regla tiene como objetivo crear las clases del modelo de dominio de A-OOH.

%El metamodelo de navegación en A-OOH se implementa en este módulo. El metamodelo definido formalmente en la Figura \ref{fig:navmetamodel} define la sintaxis abstracta para la representación conceptual en un PIM del modelo de navegación de A-OOH.

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/Content2DomainClasATL.png}
\end{center}
\caption{Implementación de la transformación \emph{Content2DomainClass} en el lenguaje ATL.}
\label{fig:Content2DomainClass}
\end{figure}

\subsection{Trazabilidad de Requisitos}\label{imp:trazabilidad}

El soporte para la trazabilidad de los requisitos a través de los modelos conceptuales de la aplicación Web se efectúa por medio de una extensión \cite{barbero2007traceability} del metamodelo de \emph{weaving}, explicado previamente en la sección \ref{c1:trazabilidad} de la tesis doctoral. La extensión para trazabilidad del metamodelo de \emph{weaving} permite generar por medio de transformaciones un modelo de trazabilidad. El modelo de trazabilidad puede ser visualizado y modificado mediante la herramienta AMW (\emph{Atlas Model Weaver}) \cite{del2006weaving}. De esta forma, es posible visualizar las correspondencias entre cada uno de los requisitos funcionales expresados en el modelo de requisitos \emph{i*} con cada uno de los elementos de los modelos conceptuales de la aplicación Web  \cite{aguilarDSDM}.

\subsection{Optimización de Pareto}\label{imp:pareto}

El algoritmo Optimización de Pareto ha sido implementado por medio del lenguaje de programación Java. Adicionalmente, ha sido necesario el uso de las clases base (\emph{core}) de EMF y el lenguaje Xpand con el fin de ser capaz de leer el modelo de requisitos \emph{i*}. El algoritmo se ha implementado como un \emph{plugin} de Eclipse para su fácil incorporación con el editor WebREd. 

La Optimización de Pareto es calculada en 3 pasos, el primero de ellos consiste en establecer la lista de prioridades para las \emph{Softgoals}, es decir, el diseñador ordenará las \emph{Softgoals} indicando cual es la de mayor importancia de acorde a lo establecido por los \emph{stakeholders}. En el segundo paso, son extraídos los requisitos funcionales así como las contribuciones que estos realizan a las \emph{Softgoals} y en el tercer paso se calcula la Optimización de Pareto. La Figura \ref{fig:imp:paretomain} muestra la ventana principal de la implementación del algoritmo.  La ventana esta dividida en 3 pestañas (\emph{Configuration}, \emph{Requirements Contributions}, \emph{The Pareto Front}), cada una de ellas corresponde a los 3 pasos necesarios para la ejecución del algoritmo. 

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/ParetoMainWindowImple.png}
\end{center}
\caption{Ventana principal del \emph{plugin} Optimización de Pareto.}
\label{fig:imp:paretomain}
\end{figure}


\subsection{Caso de estudio}\label{imp:casoestudio}

En este apartado se presenta un caso de estudio para demostrar la aplicabilidad de nuestra propuesta. El caso de estudio es el utilizado en el Capítulo \ref{c6} acerca de una aplicación Web para la gestión de conferencias (\emph{Conference Management System}). Recordemos que el propósito de la aplicación Web es brindar soporte al proceso de envío, evaluación y selección de los artículos para una conferencia. 

%Para efectos demostrativos, en este caso de estudio nos enfocaremos en la obtención del modelo de dominio, navegación y trazabilidad a partir de la especificación de requisitos.

El primer paso consiste en la especificación de los requisitos para la aplicación Web ``\emph{ContentManagementSystem}''. La Figura \ref{fig:imp:reqcasoestudio}, muestra la especificación de requisitos de la aplicación Web (modelo de requisitos). El objetivo de la aplicación Web consiste en ``\emph{Process of review of papers be selected}'', para satisfacer el objetivo, es necesario la implementación de alguno de los requisitos navegacionales ``\emph{Blind review process}'' y ``\emph{Normal review process}''. En el ejemplo el objetivo es logrado a través del requisito navegacional ``\emph{Blind review process}''. 

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/EjemploImplementacionTesisRequisitos.png}
\end{center}
\caption{Especificación de requisitos Web con \emph{i*} para el caso de estudio.}
\label{fig:imp:reqcasoestudio}
\end{figure}

El siguiente paso consiste en ejecutar las reglas de transformación para derivar automáticamente la estructura del modelo de dominio de A-OOH. En la Figura \ref{fig:imp:Service2ClassOperationATL} se muestra la regla de transformación \emph{Service2ClassOperation} (definida en la sección \ref{reglas}) implementada en ATL. 

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/Service2ClassOperationATL.png}
\end{center}
\caption{Reglas ATL para obtener las operaciones de las clases del modelo de dominio A-OOH.}
\label{fig:imp:Service2ClassOperationATL}
\end{figure}

En este caso de estudio, el modelo de dominio de A-OOH se muestra en la Figura \ref{fig:imp:DomainModelCaseStudy}. Como se puede observar, el modelo esta constituido por un \emph{UML-Package}, dentro del cual se encuentran los elementos comunes de un diagrama de clases UML tales como las clases, las operaciones dentro de las clases y las asociaciones.

\begin{figure}
\begin{center}
\includegraphics[width=0.7\textwidth]{img/DomainModelCaseStudy.png}
\end{center}
\caption{Modelo de dominio A-OOH.}
\label{fig:imp:DomainModelCaseStudy}
\end{figure}

El próximo paso es la obtención de la estructura del modelo de navegación de A-OOH. Para esto se han implementado en ATL (Figura \ref{fig:imp:CreateNavigationalModelATL}) las reglas de transformación presentadas en la sección \ref{reglas}. El proceso de derivación de un modelo de navegación permite obtener un modelo conceptual donde se especifiquen las rutas que el usuario de la aplicación Web podrá utilizar para desplazarse por el contenido. En la Figura \ref{fig:imp:NavigationalMetamodelCaseStudy} se muestra el modelo de navegación obtenido automáticamente a partir del modelo de requisitos. Como se describio en la sección \ref{modelos}, el modelo de navegación esta constituido por clases navegacionales, enlaces navegacionales y nodos navegacionales. 

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/CreateNavigationalModelATL.png}
\end{center}
\caption{Extracto de la regla ATL para obtener el modelo de navegación.}
\label{fig:imp:CreateNavigationalModelATL}
\end{figure}


%\begin{landscape}
\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/NavigationalMetamodelCaseStudy.png}
\end{center}
\caption{Modelo de navegación del caso de estudio.}
\label{fig:imp:NavigationalMetamodelCaseStudy}
\end{figure}
%\end{landscape}

Al mismo tiempo que ocurre la generación de los modelos de dominio y navegación de A-OOH se obtiene el modelo de trazabilidad (Sección \ref{c1:trazabilidad}). Esto es debido a que las reglas para crear los enlaces para trazabilidad están introducidas en las reglas ATL que derivan los modelos conceptuales. La Figura \ref{fig:imp:TraceModelReqDomain} muestra la parte de la transformación ATL donde se genera el modelo de trazabilidad dentro de la regla de transformación que derivan el modelo de dominio.

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/TraceModelReqDomain.png}
\end{center}
\caption{Extracto de la regla ATL para obtener el modelo de dominio en donde se crea el modelo de trazabilidad.}
\label{fig:imp:TraceModelReqDomain}
\end{figure}

El próximo paso consiste en visualizar el modelo de trazabilidad obtenido por medio de la herramienta AMW \emph{Atlas Model Weaver}  \cite{AtlasModelWeaver}. AMW es una herramienta que permite visualizar los enlaces contenidos en los modelos de \emph{weaving}. En la Figura \ref{fig:imp:TrazabilidadAtlasModelWeaver} se muestra el soporte para trazabilidad de A-OOH, en el lado izquiero de la imagen se visualiza el modelo de requisitos, al centro el modelo de trazabilidad y en el lado derecho se puede observar el modelo de dominio. Cuando el diseñador selecciona algún elemento de cualquier modelo (requisitos, trazabilidad o dominio) la herramienta resalta los respectivos elementos con los que corresponde el elemento seleccionado. Por último, en la parte inferior de la figura se pueden ver las propiedades de los elementos del modelo de trazabilidad.


Como se explicó en la sección \ref{modelos} de la tesis doctoral, una vez que han sido obtenidos las estructuras de los modelos de dominio y navegación el diseñador solo tendrá que refinarlos, por ejemplo, en el modelo de dominio el usuario tendrá que añadir de forma manual la cardinalidad de las asociaciones entre las clases. Más información se detalla en el Capítulo \ref{c4} de la tesis.

Una vez que se tiene un prototipo inicial de los modelos conceptuales de la aplicación, vamos a suponer que el diseñador necesita optimizar la seguridad de la aplicación Web debido a una solicitud expresa de los \emph{stakeholders}. Para esto, necesita la ejecución del \emph{plugin} Optimización de Pareto y con ello obtener como resultado un conjunto de configuraciones que le permitan saber que requisitos funcionales implementar de acuerdo a las \emph{Softgoals} que se necesiten optimizar. 

\begin{landscape}
\begin{figure}
\begin{center}
%\includegraphics[width=1.5\textwidth]{img/TrazabilidadAtlasModelWeaver.png}
\includegraphics[width=18.5cm,height=13.5cm]{img/TrazabilidadAtlasModelWeaver.png}
\end{center}
\caption{Visualización del modelo de trazabilidad en la herramienta AMW.}
\label{fig:imp:TrazabilidadAtlasModelWeaver}
\end{figure}
\end{landscape}

El \emph{plugin} para la Optimización de Pareto utiliza como modelo de entrada el modelo de requisitos \emph{i*}, así, por medio de las clases EMF y el lenguaje Xpand el modelo de requisitos es leído para extraer todos los requisitos, \emph{Softgoals} y los enlaces de contribución (\emph{contribution links}) contenidos en el. La Figura \ref{fig:imp:paretomainwithdata} muestra la ventana principal del \emph{plugin}, la cual contiene un \emph{tab pane} dividido en 3 pestañas (\emph{tabs}). La primera pestaña se llama \emph{Configuration}, en el costado izquierdo el diseñador puede cambiar los valores establecidos por \emph{default} que representan la fuerza de las contribuciones realizadas por parte de los requisitos funcionales a las \emph{Softgoals}, los valores son utilizados en el cálculo de la matriz de pesos (Sección \ref{c1:optimizacion}). En el costado derecho de la misma figura se muestra la sección en donde el diseñador establece la lista de prioridades de \emph{Softgoals}. En este caso de estudio, el diseñador necesita maximizar la \emph{Softgoal} \emph{Privacy Be Maximized} que es la relacionada con la seguridad de la aplicación Web.


\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/ParetoMainWindow.png}
\end{center}
\caption{Ventana principal del \emph{plugin} Optimización de Pareto (pestaña de configuración).}
\label{fig:imp:paretomainwithdata}
\end{figure}

En la Figura \ref{fig:imp:paretosegundapestana} se muestra la pestaña \emph{Requirements Contributions} en donde se puede ver en un listado el resultado del \emph{plugin} al extraer del modelo de requisitos \emph{í*} aquellos requisitos funcionales que realicen algún tipo de contribución a las \emph{Softgoals}. En la primera columna se encuentran listados los requisitos funcionales extraídos, cabe destacar que los requisitos funcionales listados son solo aquellos que realizan contribuciones a las \emph{Softgoals} independientemente de su estado, es decir, si se encuentran implementados o no en los modelos conceptuales de la aplicación Web. Las 6 columnas restantes corresponden con cada una de las \emph{Softgoals} extraídas del modelo de requisitos. Finalmente, en la parte inferior de la pestaña \emph{Requirements Contributions} se encuentra el botón para calcular el resultado del algoritmo Optimización de Pareto, es decir la Frontera de Pareto.

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/ParetoSecondWindow.png}
\end{center}
\caption{\emph{Plugin} Optimización de Pareto. Las contribuciones de los requisitos a las \emph{Softgoals}.}
\label{fig:imp:paretosegundapestana}
\end{figure}

El resultado de la  ejecución del algoritmo se puede ver en la Figura \ref{fig:imp:paretotercerapestana}. La pestaña \emph{The Pareto Front} muestra una tabla similar a la descrita en la sección \ref{c1:optimizacion} en donde son mostrados los resultados de la ejecución del algoritmo. Las configuraciones posibles se enlistan desde la primera columna llamada \emph{Configurations} hasta la columna 6, la variable ``I'' representa el estado implementado para un requisito funcional determinado y la variable ``N'' significa que ese requisito funcional no debe de ser implementado en los modelos conceptuales de la aplicación Web. Las configuraciones que están en la Frontera de Pareto se resaltan en color gris para que sean fáciles de identificar por parte del diseñador.


\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/ParetoThirdWindow.png}
\end{center}
\caption{\emph{Plugin} Optimización de Pareto. La Frontera de Pareto.}
\label{fig:imp:paretotercerapestana}
\end{figure}

El diseñador asistido por la tabla de la Frontera de Pareto (Figura \ref{fig:imp:paretotercerapestana}) podrá ser capaz de seleccionar la configuración final de acuerdo con la lista de prioridades de las \emph{Softgoals}. En este caso de estudio, para maximizar la seguridad de la aplicación Web, el diseñador podrá elegir entre las configuraciones ``X3'' y ``X7''. 

Finalmente,, la opción a implementar es la configuración ``X3'' debido a que la configuración ``X7'' maximiza la \emph{Softgoal} relacionada con la seguridad (+1) pero afecta demasiado (-4) a la \emph{Softgoal} \emph{Review Process Easier} la cual esta vinculada con la usabilidad de la aplicación. La configuración ``X8'' no es considerada por que no está en la Frontera de Pareto.

Una explicación más a fondo sobre el funcionamiento del algoritmo Optimización de Pareto y su adaptación a la ingeniería Web dirigida por modelos se encuentra en el Capítulo \ref{c6} y en el Apéndice \ref{a3} de la tesis doctoral.


\clearpage


\section{Conclusiones}

A continuación, se sintetiza el trabajo descrito en la tesis doctoral. En primer lugar, en la Sección \ref{aporaciones} se listan y comentan las principales aportaciones de la investigación descrita en la tesis. Posteriormente, en la Sección \ref{limitaciones} se mencionan las limitaciones dentro del ámbito de la investigación realizada. Finalmente, la Sección \ref{Trabajofuturo} presenta el trabajo que se realiza actualmente y las posibles contribuciones futuras.

\subsection{Aportaciones}\label{aporaciones}

Como se detalló en Capítulos anteriores, la Web cambia constantemente debido a la evolución constante en las tecnologías de implementación. Por consiguiente, las metodologías ingenieriles para el desarrollo de este tipo de aplicaciones necesitan adaptarse a los cambios con el fin de ofrecer al diseñador una aproximación sistemática e integral para el desarrollo de aplicaciones Web.  

En este sentido, en la tesis doctoral se ha presentado una propuesta dirigida por modelos en ingeniería Web, la cual permite la especificación de los requisitos funcionales y no-funcionales de la aplicación Web de manera integral, sistemática y bien estructurada (Capítulo \ref{c4}). 

En la propuesta, los requisitos son especificados en un modelo por medio del marco de modelado orientado a objetivos i* y a razón de que el método Web A-OOH se basa en MDA, el modelo, con los requisitos especificados, corresponde al nivel CIM de esta arquitectura. Gracias a eso, en el Capítulo \ref{c4} se demostró que es posible la derivación automática de la estructura de los modelos conceptuales de dominio y navegación del método Web A-OOH a partir de la especificación de requisitos. Debido a esto, es posible validar que los requisitos de la aplicación Web han sido reflejados en los modelos conceptuales a nivel PIM. Por lo tanto, la propuesta permite a los diseñadores disminuir el nivel de complejidad en el desarrollo de aplicaciones Web, ahorrando tiempo y esfuerzo, por lo que el costo del proyecto disminuye. 

Por otra parte, debido a la naturaleza cambiante de la Web y a su audiencia heterogénea, mantener una etapa de análisis y especificación de requisitos resulta cada vez más complicado. A razón de esto, en la tesis se describe el soporte ofrecido al diseñador de la aplicación Web por medio de una gestión integral de requisitos. Concretamente, se asiste al diseñador en aspectos como la trazabilidad de los requisitos de CIM a PIM (Sección \ref{otraspub}), el análisis de impacto en los requisitos (Capítulo \ref{c5}) y en la implementación de requisitos funcionales en base a distintas alternativas de diseño considerando la maximización de los requisitos no-funcionales (Capítulo \ref{c6}).

Además, se ha realizado una implementación en la plataforma Eclipse para apoyar cada parte de la propuesta. Como prueba de concepto, se ha desarrollado un editor gráfico para la especificación de los requisitos de la aplicación Web (Sección \ref{subseccioneditor}), así mismo, se desarrollaron un conjunto de transformaciones modelo a modelo para proveer un alto grado de automatización en la generación de los modelos conceptuales de la aplicación Web (Sección \ref{imp:transformaciones}). 

Finalmente, gracias a la capacidad y mecanismos de extensión de la plataforma \emph{Eclipse}, se desarrolló un \textit{plugin} para asistir al diseñador Web respecto a la toma de decisiones de diseño en base a los requisitos no-funcionales expresados en la especificación de los requisitos (Sección \ref{imp:pareto}). Por medio del \textit{plugin}, el diseñador de la aplicación Web podrá analizar distintas alternativas de diseño, es decir, podrá analizar y seleccionar los requisitos funcionales a implementar en los modelos conceptuales de la aplicación Web considerando la prioridad establecida sobre los requisitos no-funcionales.


\subsection{Limitaciones}\label{limitaciones}

En el transcurso de la investigación, por distintos factores, como por ejemplo la restricción de tiempo, no fue posible cubrir todos los aspectos del proceso de ingeniería de \textit{software} (análisis, especificación, validación, gestión, etc.). Por tal motivo, fueron establecidos límites en la investigación, a razón de esto, surgieron las limitaciones de la propuesta. Estas son enlistadas a continuación.

\begin{itemize}

\item La herramienta WebREd permite la especificación de los requisitos de la aplicación Web en un ambiente gráfico, pero necesita un proceso de re-ingeniería para mejorar la interfaz gráfica de usuario.

\item En lo que respecta al proceso de validación de los requisitos, solo ha sido considerada la trazabilidad de los requisitos, dejando de lado a los casos de prueba.

\item En lo que se refiere a la gestión de requisitos, la propuesta ofrece soporte para el en análisis de impacto, pero se carece de un control de versiones, propagación de cambios y herramientas para la gestión de la configuración.

\item La propuesta no está integrada en una sola herramienta, es decir, la constituyen un conjunto de \textit{plugins} de la plataforma Eclipse, por lo tanto resulta difícil su aplicación en casos reales, con lo cual resalta la necesidad de desarrollar una herramienta CASE.

\end{itemize}

\subsection{Trabajo futuro}\label{Trabajofuturo}

\begin{itemize}

\item El marco de modelado orientado a objetos i* es poco escalable, por lo que se estudiarán mecanismos que ofrezcan solución a este problema de tal forma que sea posible manejar el crecimiento de los requisitos de manera fluida, es decir, que cuando la especificación de los requisitos crezca el modelo pueda ser comprendido.

\item Definir e implementar las transformaciones modelo a modelo para la generación automática de los modelos conceptuales de usuario, personalización y presentación del método Web A-OOH.

\item Realizar distintos experimentos para comprobar el funcionamiento del algoritmo de Optimización de Pareto en casos reales.

\item Integrar la propuesta presentada en la tesis en un prototipo de herramienta CASE.

\item Extender la propuesta para la especificación de requisitos Web hacia las RIAs.

\item Analizar la distribución de los requisitos funcionales de las RIAs (cliente o servidor) para proveer un algoritmo que permita asistir al diseñador Web en el proceso de distribución de los requisitos funcionales considerando a los requisitos no-funcionales desde la etapa de análisis y especificación de requisitos.
	
\end{itemize}


Finalmente, cabe destacar que, por lo que al autor respecta, la tesis doctoral representa la primera propuesta dirigida por modelos en ingeniería Web que aplica un marco de trabajo orientado a objetivos para la etapa de análisis y especificación de requisitos en un contexto MDA y a la vez permite la generación de los modelos conceptuales de la aplicación Web en un proceso con un alto grado de automatización. Además, gracias a la integración con el método Web A-OOH se ha logrado configurar un método de ingeniería Web dirigido por modelos que consume el proceso de desarrollo de la aplicación Web basado en MDA gracias a que el proceso inicia en el modelo independiente de computación (CIM), del cual son generados los modelos independientes de la plataforma (PIM) y culminando con los modelos específicos de la plataforma.


\clearpage



\bibliographystyle{abbrv}
\bibliography{tesis}


%
