%%%%%%%%%%%%%%%%%%%%% chapter1.tex %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Capítulo de síntesis de toda la tesis.
%
%
%%%%%%%%%%%%%%%%%%%%%%%% Universidad de Alicante %%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Síntesis}
\label{c1} % Always give a unique label
% use \chaptermark{}
% to alter or adjust the chapter heading in the running head

A razón de que la tesis doctoral se ha realizado mediante la modalidad de compendio de artículos, este capítulo está dedicado a describir los objetivos, hipótesis y el conjunto de trabajos que la conforman. Además, es resumido el contenido científico de la tesis por medio de una síntesis global de los resultados obtenidos así como de las conclusiones finales. 


\section{Tesis Doctoral como Compendio de Artículos}

Los requisitos que debe cumplir una tesis doctoral para ser realizada en la Universidad de Alicante mediante un compendio de publicaciones fueron definidos por el Pleno de la Comisión de Doctorado de fecha 2 de marzo de 2005. A continuación, se exponen aquellos directamente relacionados con el contenido de la tesis:

\begin{enumerate}

\item \emph{``La tesis debe incluir una síntesis, en una de las dos lenguas oficiales de esta Comunidad Autónoma, en la que se presenten los objetivos, hipótesis, los trabajos presentados y se justifique la unidad temática.''}

\item \emph{``Esta síntesis debe incorporar un resumen global de los resultados obtenidos, de la discusión de estos resultados y de las conclusiones finales. Esta síntesis deberá dar una idea precisa del contenido de la tesis.''}

\item \emph{``Los trabajos deben ser publicados, o aceptados para la publicación, con posterioridad al inicio de los estudios de doctorado. Los artículos en periodo de revisión pueden formar parte de la tesis como apéndices del documento, que debe presentarse adjunta a los artículos publicados.''}

\end{enumerate}

Con el propósito de satisfacer los requisitos, la estructura de la tesis queda constituida en tres partes. La primera parte (Parte ~\ref{p1}) consiste en una síntesis de la tesis. La Parte~\ref{p2} presenta el conjunto de artículos publicados que forman el núcleo de la tesis. Finalmente, la Parte~\ref{p3} consiste en un apéndice donde se presentan tres trabajos, los cuales se encuentran actualmente en proceso de revisión. 

%El primer artículo, consiste en una SLR (\emph{Systematic Literature Review}) acerca del estado de la cuestión en la ingeniería de requisitos en Web, el artículo se ha enviado a el \emph{Journal of Web Engineering} \footnote{http://www.rintonpress.com/journals/jwe/}. En el 

Asimismo, es muy importante subrayar que la tesis doctoral ha sido materializada gracias al apoyo económico otorgado por el Consejo Nacional de Ciencia y Tecnología (CONACyT) México, por medio del Programa de Becas de Estudios de Posgrado en el Extranjero. Finalmente, es necesario destacar el interés y apoyo otorgado por parte de la Universidad Autónoma de Sinaloa, a través del Programa de Formación de Recursos Humanos en Áreas Estratégicas. 

\subsection{Publicaciones Pertenecientes a la Tesis Doctoral}
\label{c1:chapter}

A continuación, se describen brevemente las cuatro publicaciones seleccionadas para que formen parte de la tesis doctoral. El criterio utilizado para la selección consistió en la relevancia y contribución científica de cada una de las publicaciones. Es decir, fueron seleccionados los artículos publicados en revistas indexadas en JCR (\emph{Journal Citation Report}\footnote{http://www.thomsonreuters.com/}) y en congresos ubicados en la clasificación CORE (\emph{Computer Research and Education}\footnote{http://www.core.edu.au/}).

\subsubsection{Capítulo~\ref{c3}}

\emph{J.A. Aguilar, I. Garrig{\'o}s, J.-N. Maz{\'o}n, J. Trujillo. Web Engineering Approaches for Requirements Analysis - A Systematic Literature Review. 6th Web Information Systems and Technologies (WEBIST 2010), Vol. 2, pp. 187-190, 2010.}

El capítulo presenta una revisión sistemática de la literatura con el fin de obtener el estado de la cuestión en lo referente a métodos para la especificación, análisis y modelado de requisitos en ingeniería Web así como las herramientas de soporte ofrecidas por cada uno de los métodos considerados. Por último, los resultados obtenidos muestran, entre otras cosas, que gran parte de las metodologías Web no ofrecen un soporte integral en la etapa de análisis y especificación de requisitos.

\subsubsection{Capítulo~\ref{c4}}

\emph{J.A. Aguilar, I. Garrig{\'o}s, J.-N. Maz{\'o}n, J. Trujillo. An MDA Approach for Goal-oriented Requirement Analysis in Web Engineering. Journal of Universal Computer Science (J.UCS), 16(17): 2475-2494 (2010).}

El capítulo describe la propuesta base de la tesis, la cual consiste en el desarrollo de una metodología para la gestión de requisitos en ingeniería Web. En el capítuo anterior, se realizó una revisión sistemática de la literatura para estudiar las técnicas ingenieriles en el desarrollo de aplicaciones Web, los resultados demuestran que la mayoría de las aproximaciones se enfocan en las etapas de análisis y diseño, por tanto, no ofrecen un soporte integral a la fase de requisitos. La aproximación descrita en este capítulo, ha tomando como sustento las carencias detectadas en el capítulo anterior para desarrollar una aproximación basada en el marco de modelado orientado a objetivos \emph{i*} y en MDA (\emph{Model-Driven Architecture}). La propuesta le permite al diseñador de la aplicación Web derivar la estructura de los modelos conceptuales que conforman la aplicación a partir de la especificación de requisitos. Finalmente, la derivación se realiza por medio de un conjunto de transformaciones descritas de manera formal utilizando el lenguaje QVT \footnote{\emph{Query/View/Transformation}}.

\subsubsection{Capítulo~\ref{c5}}

\emph{J.A. Aguilar, I. Garrig{\'o}s, J.-N. Maz{\'o}n. Impact Analysis of Goal-Oriented Requirements in Web Engineering. The 11th  International Conference on Computational Science and Its Applications (ICCSA 2011), June 20-23, 2011, Santander, Spain. Part V, Lecture Notes in Computer Science, Vol. 6786, pp. 421-436, 2011.}

En capítulos anteriores se ha resaltado la importancia de la etapa de análisis y especificación de requisitos en la ingeniería Web, obligada, principalmente, por las características particulares de este tipo de aplicaciones, tales como su audiencia heterogénea y por la evolución constante en las tecnologías de implementación. Este tipo de características originan que la aplicación Web sea propensa a sufrir cambios, por eso, es importante conocer en qué medida impactarán los cambios a los requisitos, así como qué partes de la aplicación Web se verán afectadas. Para lograrlo, es necesario comprender y analizar las dependencias entre los requisitos, es decir, cuales requisitos están relacionados o cuales dependen uno del otro para cumplirse y con ello brindar soporte al diseñador por medio de una mejor gestión y mantenimiento de la aplicación Web. 

En este capítulo, se presenta un algoritmo para manejar las dependencias entre los requisitos funcionales y los requisitos no-funcionales de la aplicación Web en un contexto orientado a objetivos (\emph{goal-oriented}). Con el algoritmo, es posible comprender cuál es el impacto en los requisitos procedente de un cambio en la estructura de modelos conceptuales que conforman la aplicación Web, así como saber qué requisitos necesitan ser implementados para cumplir, en medida de lo posible, los propósitos establecidos en el análisis orientado a objetivos.

%esto ocasiona inconsistencias entre los requisitos, es decir, los requisitos elicitados no reflejan el producto \emph{software} obtenido como resultado del proceso de desarrollo. Por consiguiente, es importante conocer la correspondencia entre los requisitos y el producto \emph{software} obtenido para garantizar, en lo posible, que los requisitos sean reflejados en el producto. Comprender y análizar las dependencias entre los requisitos le permite al diseñador brindar una mejor gestión y mantenimiento de la aplicación Web. En este capítulo, se presenta un algoritmo para manejar las dependencias entre los requisitos funcionales y los requisitos no-funcionales de la aplicación Web en un contexto orientado a objetivos (\emph{goal-oriented}). Con el algoritmo, es posible comprender cuál es el impacto en los requisitos procedente de un cambio en los modelos conceptuales que conforman la aplicación Web, así como saber qué requisitos necesitan ser implementados para cumplir, en medida de lo posible, los proósitos establecidos en el análisis orientado a objetivos.


\subsubsection{Capítulo~\ref{c6}}

\emph{J.A. Aguilar, I. Garrig{\'o}s, J.-N. Maz{\'o}n. A Goal-Oriented Approach for Optimizing Non-Functional Requirements in Web Applications. The 8th  th International Workshop on Web Information Systems Modeling (WISM 2011), held in conjunction with the International Conference on Conceptual Modeling (ER 2011), 31 October - 03 November 2011, Brussels, Belgium. Lecture Notes in Computer Science, Vol. 6999, In press.}

%El contenido de este capítulo aborda la implementación del algoritmo de Pareto 

La idea de considerar a los requisitos no-funcionales desde la etapa de análisis y especificación de requisitos, con el fin de mejorar la calidad de la aplicación a desarrollar, ha sido objeto de investigación en el contexto del desarrollo dirigido por modelos (\emph{Model-Driven Development}). Para ello, es necesario considerar a los requisitos funcionales así como a los no-funcionales debido a que los dos poseen la habilidad de satisfacer las necesidades de los \emph{stakeholders} y por lo tanto, ambos tipos de requisitos afectan la calidad de un producto de \emph{software}, según lo establecido en la ISO/IEC 9126-1:2001, en la sección de \emph{Product Quality}, específicamente en  la primera parte \emph{Quality Model}.

En este capítulo se presenta una adaptación del algoritmo Optimización de Pareto para evaluar y seleccionar la configuración de requisitos óptima que maximice los requisitos no-funcionales de la aplicación Web. Una configuración de requisitos óptima esta formada por el sub conjunto de requisitos funcionales que se deberán implementar en los modelos conceptuales de la aplicación. La idea del capítulo se fundamenta en cómo es que la implementación de los requisitos funcionales afecta o beneficia a los requisitos no-funcionales. Para esto, los requisitos no-funcionales deben de ser priorizados de acorde al contexto de los usuarios de la aplicación Web. Finalmente, la solución del algoritmo proporciona al diseñador de la aplicación un conjunto de configuraciones de entre las cuales podrá elegir qué requisitos funcionales implementar (configuración óptima) considerando la prioridad establecida por los \emph{stakeholders} sobre los requisitos no-funcionales.



\subsection{Artículos en Proceso de Revisión Pertenecientes a la Tesis Doctoral}
\label{c1:appendix}

En este apartado, se presentan dos trabajos que forman parte de la tesis doctoral. Los trabajos están actualmente bajo proceso de revisión.

\subsubsection{Apéndice~\ref{a1}}

\emph{Requirements in Web engineering: a systematic literature review. Este artículo se ha enviado a la revista Journal of Web Engineering (JWE).}

En este trabajo se realiza una profunda revisión del estado de la cuestión en lo referente al análisis, especificación y trazabilidad de requisitos en ingeniería Web. Concretamente, se analizan: (i) las técnicas utilizadas por las metodologías ingenieriles en la etapa de análisis y especificación de requisitos, (ii) el tipo de requisitos y la terminología utilizada por cada metodología, (iii) el soporte para trazabilidad y (iv) las herramientas de soporte que ofrecen. 

Cabe destacar que el artículo es una extensión del Capítulo~\ref{c3}, en el que se destaca la importancia de considerar a los requisitos en el desarrollo de sistemas Web. En particular, en la revisión sistemática de la literatura presentada en el apéndice, se ha mejorado el trabajo descrito en el Capítulo~\ref{c3} de la siguiente forma:

\begin{itemize}
	\item La estrategia de búsqueda ha sido mejorada, por lo tanto se han añadido más métodos
a la revisión.

\item El estudio se ha centrado en analizar el proceso de ingeniería de requisitos en el desarrollo de aplicaciones Web, es decir, en qué forma los requisitos son tratados en lo que respecta a la obtención, análisis, especificación, validación y la gestión de los mismos. 

\item La revisión sistemática analiza el vocabulario que ha sido adoptado por cada 
método de ingeniería Web de una manera metódica y completa mediante el uso de la clasificación propuesta por Escalona y Koch \cite{EscalonaK04}.
\end{itemize}

\subsubsection{Apéndice~\ref{a2}}

\emph{A Goal-Oriented Requirements Engineering Approach to Distribute Functionality in RIAs. Este artículo se ha
enviado a 12th International Conference on Web Information System Engineering (WISE 2011).}*************

Como es sabido, las tecnologías de implementación de las aplicaciones Web evolucionan constantemente. Parte de la evolución son las aplicaciones RIAs (\emph{Rich Internet Applications}), las cuales ofrecen, entre otras cosas, una mejor interactividad con el usuario, similar a la ofrecida por las aplicaciones \emph{software} de escritorio. En este trabajo, se presenta la adaptación de la propuesta descrita en el Capítulo ~\ref{c4} para auxiliar al diseñador Web en la distribución de la funcionalidad de la aplicación RIA entre el cliente y el servidor. Para lograrlo, se adaptó el algoritmo Optimización de Pareto para obtener un conjunto de soluciones óptimas, de entre las cuales, de acuerdo con la prioridad establecida por parte del \emph{stakeholder} sobre los requisitos no-funcionales, el diseñador de la aplicación Web será capaz de elegir la configuración que maximice a los requisitos no-funcionales. De esta forma, es posible optimizar los requisitos no-funcionales mediante la distribución de los requisitos funcionales entre el cliente y el servidor.

\subsubsection{Apéndice~\ref{a3}}

\emph{Dealing with dependencies among functional and non-functional requirements for impact analysis in Web engineering. Este artículo se ha
enviado a International Journal of Open Source Software & Processes (IJOSSP).}

Este apéndice es una extensión del Capítulo \ref{c5} acerca de la importancia de considerar el análisis de impacto nuestro método orientado a objetivos para el análisis y especificacion de requisitos en Web. En particular, la novedad de la extensión consiste en: (i) la implementación del perfil UML para adaptar el marco de modelado i* en el dominio Web como un metamodelo, (ii) el desarrollo de un prototipo de herramienta para la especificación de requisitos Web como prueba de concepto de nuestra propuesta, (iii) la implementación de las reglas de transformación (con un alto grado de automatización) para derivar los modelos conceptuales de la aplicación Web, y (iv) la implementación del algoritmo para el análisis de impacto en el modelo de requisitos orientado a objetivos.

\subsection{Otras Publicaciones}

En el transcurso de la investigación asociada a la tesis doctoral se han publicado cinco artículos en distintos eventos nacionales y/o internacionales. Cabe destacar que los trabajos no han sido incluídos en el núcleo de la tesis, sin embargo, complementan el progreso de la investigación. Los artículos son listados a continuación:

%\subsubsection{Publicaciones en Revistas Internacionales}

\begin{description}

\item[\textbf{J.A. Aguilar}, I. Garrig{\'o}s, J.-N. Maz{\'o}n.] Aproximaciones en Ingeniería Web para el Análisis de Requisitos: una Revisión Sistemática de la Literatura. \emph{Actas del IV Congreso Nacional de Informática y Ciencias de la Computación (CNICC 2009), Mazatlán, Sinaloa, México, 2009.}

\item[\textbf{J.A. Aguilar}, I. Garrig{\'o}s, J.-N. Maz{\'o}n.] Modelos de \emph{weaving} para Trazabilidad de Requisitos Web en A-OOH. \emph{Actas del VII Taller de Desarrollo de Software Dirigido por Modelos (DSDM 2010) en XV Jornadas de Ingeniería de Software y Bases de Datos (JISBD 2010), en conjunto con el Congreso Español de Informática (CEDI), pp. 146-155. SISTEDES, Valencia, España, 2010}. ISSN 1988\-3455.

\item[\textbf{J.A. Aguilar}, I. Garrig{\'o}s, J.-N. Maz{\'o}n.] Modelo Requisitos y Modelo de Dominio, trazabilidad mediante modelos de \emph{Weaving}. \emph{Actas de VIII Jornadas para el Desarrollo de Grandes Aplicaciones de Red (JDARE 2010). GrupoM, Alicante, España, 2010}. ISBN: 978-84-614-3720-7.

\item[\textbf{J.A. Aguilar}, I. Garrig{\'o}s, J.-N. Maz{\'o}n.] Automatic Generation of Conceptual Models from Requirements Specification in Web Engineering using ATL. \emph{Actas de IX Jornadas para el Desarrollo de Grandes Aplicaciones de Red (JDARE 2011). GrupoM, Alicante, España, 2011. Aceptado.}

\item[\textbf{J.A. Aguilar}, I. Garrig{\'o}s, J.-N. Maz{\'o}n.]Una Propuesta Orientada a Objetivos para el Análisis de Requisitos en RIAs. \emph{Actas de XVI Jornadas de Ingeniería de Software y Bases de Datos (JISBD 2011). La Coruña, España, 2011. ISSN XXXX\-XXXX.}

\end{description}

\section{Hipótesis Inicial y Objetivos de Investigación}
\label{c1s1} 

De forma similar a los sistemas \emph{software} desarrollados exclusivamente para un entorno de escritorio, los sistemas Web necesitan la aplicación de conceptos de ingeniería para obtener éxito en la aplicación final. Para lograrlo, es necesario definir técnicas y enfoques que consideren la gran variedad de usuarios, plataformas y entornos para su implementación. En este sentido, uno de los factores de éxito más importantes en el desarrollo de \emph{software} es la elicitación, gestión y análisis de requisitos. La gestión de requisitos es el proceso de comprender y controlar los cambios en los requisitos de la aplicación \cite{Sommerville96}. 

Sin embargo, en el desarrollo de \emph{software} en ingeniería Web llevar a cabo una correcta gestión de los requisitos es una tarea complicada. Principalmente, esto se debe a que la ingeniería Web enfrenta continuos cambios en lo que respecta a la tecnología de implementación los cuales dificultan la etapa de análisis y especificación de requisitos a razón de las características particulares de las aplicaciones Web, como el caso de: (i) la gran cantidad de información que ofrecen (contenido), (ii) el acceso a los diferentes escenarios donde ofrecen esa información (navegación), (iii) cómo proveer dicha información al usuario o grupos de usuarios (funcionalidad) del sitio Web y (iv), la audiencia heterogénea que tiene acceso a la Web. Como consecuencia de estos factores, los analistas, desarrolladores y diseñadores se enfrentan a retos cada vez más complejos para gestionar el diseño y mantenimiento de las aplicaciones Web. Por lo tanto, definir los requisitos (funcionales y no-funcionales) que el sistema debe cumplir para satisfacer las necesidades de los usuarios es una tarea que necesita una atención especial. 

Actualmente, existen una notable cantidad de aproximaciones metodológicas para el desarrollo de aplicaciones Web (A-OOH \cite{Garrigos09}, UWE \cite{Koch02}, NTD \cite{escalona2004developing}, OOWS \cite{OOWS2001}, etc.) que toman en cuenta la aplicación de distintas técnicas para llevar a cabo el desarrollo, la mayoría de ellas utilizan reconocidas técnicas de ingeniería de \emph{software} para gestionar correctamente los requisitos de los usuarios, como el caso de UWE (casos de uso) \cite{KochTypesOfReq}. Lamentablemente, la mayoría de las técnicas utilizadas por las metodologías resultan insuficientes para representar características muy particulares de las aplicaciones Web, tales como: la navegación y la audiencia heterogénea. Por lo tanto, es necesaria la inclusión de nuevas técnicas que permitan lidiar con las características particulares de las aplicaciones Web y que además posibiliten la correcta especificación de las necesidades de los diferentes actores implicados. 

Por otro lado, la ingeniería dirigida por modelos (\emph{Model-Driven Engineering}, MDE) es una metodología de trabajo que incorpora un  conjunto de métodos, técnicas y tecnologías para llevar a cabo el proceso de desarrollo en base a modelos. MDE guía el proceso en base a
conceptos y reglas tomados directamente de una área de interés determinada, es decir, del dominio del problema \cite{MDE}. Para esto, MDE incorpora conceptos de la ingeniería de software e ingeniería de requisitos, tales como los modelos de madurez \cite{SEI}, los marcos de trabajo conceptuales como las metoddologías ágiles, trazabilidad de los productos de trabajo \footnote{Cualquier artefacto producido por un proceso. Estos artefactos pueden incluir archivos, documentos, piezas de los productos, servicios, procesos y especificaciones \cite{cmmi4development}.} deribados del proceso de desarrollo \cite{SEI} y la evolución del software \cite{Sommerville96}. 

No obstante, el desarrollo dirigido por modelos (\emph{Model Driven Development}, MDD), se manifiesta como un paradigma de desarrollo que abstrae MDE mediante la utilización de modelos como artefactos principales en el proceso de desarrollo de \emph{software}. MDD se ha convertido en una alternativa valiosa para resolver los problemas asociados con el desarrollo de \emph{software} de manera sistemática, estructurada, integrada y completa \cite{aguilarDSDM} por medio del modelado del sistema \emph{software} y su generación a partir de los modelos. Es importante resaltar que MDD sólo proporciona una estrategia general a seguir en el desarrollo de \emph{software} dirigido por modelos, pero no define las técnicas a utilizar. 

En este contexto, la arquitectura dirigida por modelos (\emph{Model Driven Architecture}, MDA) \cite{MDA} surge como un estándar del OMG  (\emph{Object Management Group}) \cite{OMG} que promueve el MDD. MDA está formada por un conjunto de capas y transformaciones que proporcionan un marco conceptual de trabajo en donde encontramos tres tipos de modelos, el primero de ellos es modelo independiente de la computación (\emph{Computational Independent Model}, CIM), utilizado para la especificación de los requisitos de la aplicación a desarrollar, el segundo es el modelo independiente de la plataforma (\emph{Platform Independent Model}, PIM), como su nombre lo indica, se caracteriza por ser independiente de la plataforma de implementación de la aplicación, por ejemplo, un diagrama de clases, y el modelo específico de la plataforma (\emph{Platform Specific Model}, PSM), el cual es obtenido del PIM y contiene la información sobre una plataforma de desarrollo o alguna tecnología en especifico donde será implementada la aplicación final, esto es, el código fuente de la aplicación \cite{MDA}. 

MDA ha tenido un gran impacto en la comunidad de ingeniería Web, esto es debido a las ventajas que ofrece llevar a cabo el proceso de desarrollo de aplicaciones Web mediante el uso de modelos conceptuales, por ejemplo, acortar el tiempo de desarrollo de la aplicación Web, lo cual puede resultar, en algunos casos, en un ahorro en el costo del projecto. El impacto de MDA en la ingeniería Web ha permitido la llegada de la ingeniería Web dirigida por modelos (\emph{Model Driven Web Engineering}, MDWE) como una nueva aproximación para el desarrollo de aplicaciones Web \cite{kochMDWE, MDWE}. Su supuesto básico es la consideración de los modelos como entidades de primera clase que impulsan el proceso de desarrollo desde el análisis de requisitos hasta la implementación final. Básicamente, cada paso del proceso consiste en la generación de uno o más modelos de salida a partir de uno o más modelos de entrada. Por lo tanto, las transformaciones entre modelos son la clave para completar cada paso del proceso de desarrollo dirigido por modelos.

En la actualidad, MDA ha sido aplicado para el desarrollo de aplicaciones Web por parte de ciertas metodologías tales como OOWS \cite{OOWSMDA}, NDT \cite{NDT} y UWE \cite{KochModelTRans}. Lamentablemente, a pesar que se ha resaltado la importancia de la etapa de análisis de requisitos en Web \cite{Aguilar2010}, algunas metodologías dan poca importancia ala especificación de requisitos (OOWS \cite{OOWS2001}, OOHDM \cite{OOHDM1995}, WSDM \cite{WSDM} y HERA \cite{Hera}) otras, por su parte, consideran la especificación de requisitos a nivel CIM de MDA utilizando técnicas como los casos de uso (UWE \cite{Koch02}). Sin embargo, por lo que al autor concierne, el trabajo presentado en la tesis doctoral es el primero que aborda el modelado conceptual de aplicaciones Web a partir del nivel CIM de MDA utilizando técnicas orientadas a objetivos (por medio del marco de trabajo \emph{i*} \cite{istarWiki}) \cite{AguilarJUCS}. De esta forma, es posible la obtención, con alto grado de automatización, de la estructura de los modelos conceptuales a nivel PIM directamente de la especificación de requisitos. Una de las principales ventajas de la propuesta es que se asegura que los modelos conceptuales obtenidos a partir del nivel CIM de MDA sean correctos semánticamente. Asimismo, ofrece al diseñador soporte para la gestión de los requisitos, por ejemplo visualización de la trazabilidad, análisis de impacto así como la selección de alternativas de diseño que consideren el balance y maximización de los requisitos no-funcionales.

Cabe destacar que la \textbf{hipótesis de partida} de la investigación asociada a la tesis doctoral consiste en que sí es factible el desarrollo de una metodología MDD-MDA que contemple una etapa integral para el análisis y especificación de requisitos que asista al diseñador en: (i) la comprensión de los objetivos y expectativas de la audiencia heterogénea de una aplicación Web, (ii) brinde soporte en la gestión de los requisitos (trazabilidad y análisis de impacto) y (iii) proveer un conjunto de alternativas de diseño basadas en la prioridad de los requisitos no-funcionales.

El \textbf{objetivo de investigación} de la tesis doctoral es la propuesta de una metodología para el análisis y especificación de requisitos para aplicaciones Web, que considere:

\begin{itemize}
   \item Una etapa de análisis de requisitos orientada a objetivos para representar las expectativas reales de los stakeholders de la aplicación Web.
   \item Mecanismos para la comprensión de los objetivos de negocio, los cuales, gracias al uso del análisis de requisitos orientada a objetivos, deben de ser alcanzados por medio de la aplicación Web.
   \item Soporte integral para la gestión de los requisitos en aspectos como la trazabilidad y el análisis de impacto. Esto permitirá verificar que los requsiitos han sido reflejados en la aplicación final así como analizar el impacto en los requisitos derivado a la evolución de la aplicación Web.  
   \item Asistir al diseñador al momento de la selección de los requisitos funcionales a implementar a través de alternativas de diseño que consideren el balance y maximización de los requisitos no-funcionales, de esta forma los requisitos no-funcionales son considerados desde la etapa de análisis y especificación de requisitos con el fin de mejorar la calidad de la aplicación Web a desarrollar.
   \item Un alto grado de automatización en el desarrollo de aplicaciones Web por medio de un conjunto de transformaciones para obtener la estructura de los modelos conceptuales a partir de la especificación de los requisitos y con esto brindar soporte a la generación del código de la aplicación Web.
\end{itemize}
 

\section{Resumen del Contenido de la Tesis Doctoral}
\label{c1s3}

El objetivo de investigación de la tesis doctoral se aborda en dos etapas, la primera es la definición de una propuesta orientada a objetivos para el análisis y especificación de requisitos en ingeniería Web. La finalidad de la primera etapa es la obtención de la estructura de los modelos conceptuales de la aplicación Web. La segunda, consiste en la especificación y aplicación de técnicas para la gestión de requisitos, concretamente, aquellas relacionadas con la trazabilidad de requisitos, análisis de impacto y alternativas de diseño en base a la maximización de requisitos no-funcionales.


\subsection{Una Aproximación Orientada a Objetivos para el Análisis de Requisitos en Ingeniería Web}\label{modelos}

En este apartado se resume la propuesta para el análisis y especificación de requisitos en ingeniería Web aplicada por medio del marco de modelado orientado a objetivos \emph{i*} y el método de ingeniería Web A-OOH (\emph{Adaptive Object-Oriented Hypermedia}) \cite{Garrigos09, AguilarJUCS}. 

A-OOH \cite{irene08}, es la extensión del método OOH (\emph{Object-Oriented Hypermedia}) \cite{GomezOOH} con soporte de personalización. El proceso de desarrollo de A-OOH esta basado en MDA \cite{MDA}, es decir, la aplicación Web es obtenida a partir de una serie de modelos conceptuales. Los modelos conceptuales corresponden al nivel PIM de la arquitectura MDA como puede verse en Fig. \ref{fig:approach}, estos son: 

%los requisitos de la aplicación Web son definidos en un nivel CIM

\begin{itemize}
   \item \textbf{Modelo de dominio}. El modelo de dominio de A-OOH se expresa como un diagrama de clases UML (\emph{Unified Modeling Language}) \cite{UML}. Este modelo refleja la parte estática de la aplicación Web encapsulando su estructura y funcionalidad. Los elementos principales para el modelado de un diagrama de clases son las clases (con sus atributos y operaciones) y sus relaciones.
	\item \textbf{Modelo de navegación}. El modelo de navegación de A-OOH se compone de nodos de navegación y las relaciones entre ellos. Este modelo indica los caminos de navegación que el usuario puede seguir en la Web (enlaces de navegación). Hay tres tipos de nodos: (i) clases navegacionales (que son vistas parciales de las clases de dominio), (ii) destinos navegacionales (que agrupan elementos del modelo que colaboran en el cumplimiento de uno o más requisitos de navegación del usuario) y (iii) colecciones (que son estructuras, posiblemente jerárquicas, que se definen entre clases de navegación o destinos navegacionales). La colección más común es la colección de clasificación (\emph{C-collection}), que actúa como un mecanismo de abstracción para el concepto de \emph{menú} agrupando enlaces de navegación. Con respecto a los enlaces de navegación, A-OOH define dos tipos principales: enlaces de travesía (\emph{Transversal-links}) (definidos entre dos nodos de navegación) y enlaces de servicio (\emph{Service-links}), en donde la navegación sucede al activar una operación que modifica la lógica de negocio y además implica la navegación a un nodo mostrando información cuando la ejecución del servicio ha finalizado.
   \item \textbf{Modelo de presentación}. Este modelo permite definir la interfaz gráfica de la aplicación Web, por ejemplo el tipo de fuente utilizada en el texto, el color, etc.
   \item \textbf{Modelo de personalización}. Este modelo es utilizado para la especificación de estrategias de personalización.
   \item \textbf{Modelo de usuario}. Este modelo permite la descripción de los usuarios en términos de información personal, sus relaciones con un dominio en particular y las acciones de navegación realizadas en tiempo de ejecución. La estructura de la información necesaria para la personalización también se describe en este modelo.   
\end{itemize}

\begin{figure}
\begin{center}
\includegraphics[width=0.8\textwidth]{img/approach.png}
\end{center}
\caption{La propuesta de la tesis doctoral integrada como CIM en el método Web A-OOH.}
\label{fig:approach}
\end{figure}


\subsubsection{Especificación del Modelo de Requisitos a Nivel CIM}\label{especificacion}

El primer paso de la propuesta presentada en la tesis doctoral es la especificación y el modelado de los requisitos de la aplicación Web. Para una explicación más amplia el lector puede referirse al Capítulo \ref{c4} de la tesis doctoral.

Los requisitos Web se definen en un modelo independiente de computación (CIM) utilizando el marco de modelado de requisitos \emph{i*}. El marco de modelado \emph{i*}  \cite{Yu95, Yu97} es uno de los más utilizados para analizar los objetivos de los \emph{stakeholder's} \footnote{Las personas u organizaciones que afectan o son afectados directa o indirectamente por el proyecto de desarrollo de software en una forma positiva o negativa \cite{Sommerville96}.} (actores en \emph{i*}) y cómo el sistema a diseñar debería satisfacerlos. Además, \emph{i*} permite razonar acerca de cómo estos objetivos pueden contribuir a la selección de diferentes alternativas de diseño según su viabilidad. Con el fin de motivar esta parte de la investigación, se ha realizado una revisión del estado de la cuestión (ver Capítulo \ref{c3} y Apéndice~\ref{a1}) acerca de las técnicas utilizadas para el análisis y especificación de requisitos en ingeniería Web.

El marco de modelado \emph{i*} consiste básicamente en dos modelos: el modelo SD (\emph{Strategic Dependency}) para especificar las relaciones de dependencia entre varios actores en un contexto organizacional y el modelo SR (\emph{Strategic Rationale}), utilizado para describir los intereses y preocupaciones del actor y como es que podrían abordarse. El modelo SR permite el modelado de las relaciones de asociación entre cada actor y sus dependencias, por tanto, proporciona información acerca de cómo los actores llegan a sus objetivos. El modelo SR incluye sólo los elementos considerados lo suficientemente importante como para influir el alcance de un objetivo. El modelo SR muestra las dependencias de los actores mediante la inclusión del modelo SD. En torno a estas dependencias el modelo SR especifica los elementos intencionales tales como \emph{Goals}), tareas (\emph{Tasks}), recursos (\emph{Resources}) y \emph{Softgoals} (Tabla \ref{tab:istarsymbols}. En comparación con el modelo SD, los modelos SR proporcionan un nivel de modelado más detallado, debido a que permiten modelar las relaciones internas e intencionales dentro de los actores. Las relaciones intencionales son enlaces del tipo \emph{Meands-end} y representan formas alternativas para satisfacer objetivos; los \emph{Decomposition-links} representan los elementos necesarios para que una tarea sea realizada; o los \emph{Contribution-links} que sirven para modelar cómo es que un elemento intencional contribuye a la satisfacción de un requisito no-funcional (\emph{Softgoal}). En la Tabla \ref{tab:istarsymbols} se describen los elementos más importantes del marco de modelado \emph{i*}, para información más extendida el lector puede consultar \cite{istarWiki}. 

%\begin{table}
%\centering
%\tiny
%\caption{La notación de \emph{i*}.}\label{tab:istarsymbols}
%\begin{tabular}{|c|c|c|c|}
%\hline
%\textbf{Símbolo} & \textbf{Nombre} & \textbf{Símbolo} & \textbf{Nombre}\\
%\hline
%\includegraphics[height=3mm]{img/dependency.eps} & SD Model & \includegraphics[height=3mm]{img/boundary.eps} & SR Model\\
%\includegraphics[height=3mm]{img/iactor.eps} & Actor & \includegraphics[height=3mm]{img/goal.eps} & Goal \\
%\includegraphics[height=3mm]{img/task.eps} & Task & \includegraphics[height=3mm]{img/resource.eps} & Resource\\
%\includegraphics[height=3mm]{img/softgoal.eps} & Softgoal & \includegraphics[height=3mm]{img/means-end.eps} & Means-end link\\
%\includegraphics[height=3mm]{img/decomposition.eps} & Task-decomposition link & \includegraphics[height=3mm]{img/contribution.eps} & Contribution link\\
%\hline
%\end{tabular}
%\end{table}

\begin{table}
\caption{Principales elementos para el modelado en \emph{i*}}
\label{tab:istarsymbols}
\begin{tabular}{p{0.3\textwidth}p{0.2\textwidth}p{0.4\textwidth}}
\hline\noalign{\smallskip}
Elemento & Icono& Descripción  \\
\noalign{\smallskip}\hline\noalign{\smallskip}
\textsc{Actor} & (\includegraphics[height=3mm]{img/iactor.eps}) & Es una entidad que lleva a cabo acciones para cumplir con sus objetivos. Se relaciona con varios elementos intencionales (objetivo, tarea o recurso).\\
\textsc{Goal} & (\includegraphics[height=3mm]{img/goal.eps}) & Representa una condición o estado que el actor le gustaría alcanzar. Lamentablemente no detalla como es que se satisfará el objetivo.\\
\textsc{Task} & (\includegraphics[height=3mm]{img/task.eps}) & Representa una manera particular de hacer algo. \\
\textsc{Softgoal} & (\includegraphics[height=3mm]{img/softgoal.eps}) & Representan criterios de calidad. Son utilizadas cuando los objetivos del \emph{stakeholder} no son precisos o sus criterios de éxito no están claramente definidos.\\
\textsc{Resource} & (\includegraphics[height=3mm]{img/resource.eps}) & Es una entidad que debe estar disponible para su uso.\\
\textsc{Means-ends} & (\includegraphics[height=3mm]{img/means-end.eps}) & Son asociaciones que describen cómo se alcanzan los objetivos, es decir, los posibles caminos para satisfacer un objetivo. \\
\textsc{Decomposition} & (\includegraphics[height=3mm]{img/decomposition.eps}) & Son asociaciones que definen elementos adicionales necesarios para llevar a cabo una tarea. \\
\noalign{\smallskip}\hline\noalign{\smallskip}
\end{tabular}
\end{table}

Por otra parte, debido a las características particulares de las aplicaciones Web, tales como el contenido que ofrecen, la navegación, la funcionalidad y la audiencia hterogénea (para más información consultar Capítulo \ref{c3} y Apéndice~\ref{a1}) el marco de modelado \emph{i*} resulta insuficiente para representarlas por sí solo. Por tal motivo, debe de adaptarse al dominio Web para poder ser utilizado en la especificación y análisis de requisitos. Esto permitirá modelar a los actores con sus objetivos y las relaciones existentes entre ellos. Para realizar la adaptación de \emph{i*} al dominio Web nuestra propuesta utiliza la taxonomía de requisitos Web presentada en \cite{EscalonaK04}, la cual clasifica a los requisitos Web en seis tipos. Estos son descritos a continuación:

\begin{itemize}
   \item \textbf{Requisitos de contenido (\emph{Content})}. Con este tipo de requisitos se define el contenido que el sitio Web presenta a sus usuarios. Algunos ejemplos pueden ser:  ``información del libro'' o ``categorías del producto''.
   \item \textbf{Requisitos de servicio (\emph{Service})}. Este tipo de requisito hace referencia a la funcionalidad interna que el sistema debe proveer a los usuarios. Por ejemplo: ``registrar un nuevo cliente'', ``agregar un producto'', etc.
   \item \textbf{Requisitos de navegación (\emph{Navigational})}. Un sistema Web debe también definir caminos de navegación disponibles para los usuarios. Algunos ejemplos son: ``consultar productos por categoría'', ``consultar el carrito de compras'', etc.
   \item \textbf{Requisitos de interfaz (\emph{Layout})}. Los requisitos también pueden definir la interfaz visual para los usuarios. Por ejemplo: ``presentar un estilo diferente para los adolescentes''.
   \item \textbf{Requisitos de personalización (\emph{Personalization})}. El diseñador puede especificar las acciones de personalización a ser ejecutadas en el sitio Web. Por ejemplo: ``adaptar el estilo de la fuente para las personas con deficiencia visual''.
   \item \textbf{Requisitos no funcionales (\emph{Non-functional requirements})}. Estos requisitos representan criterios de calidad que el sistema debe conseguir. Algunos ejemplos de estos requisitos pueden ser: ``eficiencia'', ``atraer más usuarios'' y ``buena experiencia del usuario''.
\end{itemize}

Finalmente, para poder utilizar el marco de modelado \emph{i*} dentro de MDA se ha implementado un metamodelo. El metamodelo se implementó utilizando la tecnología EMF (\emph{Eclipse Modeling Framework}) de Eclipse \cite{ECLIPSE} (Fig. \ref{fig:SeccionRequisitosWebMetamodelo}). Los elementos intencionales de \emph{i*} fueron extendidos con nuevas clases para representar cada uno de los tipos de requisitos Web descritos anteriormente (\emph{Navigational}, \emph{Service}, \emph{Personalization}, \emph{Layout} y \emph{Content}). Los requisitos no-funcionales se modelan directamente utilizando elementos de \emph{i*} (\emph{Softgoals}). 

%\begin{figure}
%\begin{center}
%\includegraphics[width=\textwidth]{img/SeccionRequisitosWebMetamodelo.eps}
%\end{center}
%\caption{Extracto de metamodelo de requisitos Web del método A-OOH.}
%\label{fig:reqmetamodel}
%\end{figure}
\begin{landscape}
\begin{figure}
\begin{center}
\includegraphics[width=1.8\textwidth]{img/WebRequirementsMetamodel.png}
\end{center}
\caption{Metamodelo para la especificación de requisitos Web con \emph{i*}.}
\label{fig:SeccionRequisitosWebMetamodelo}
\end{figure}
\end{landscape}

A continuación, se resume la generación de la estructura de los modelos conceptuales de A-OOH. Se remite al lector a los capítulos
específicos de la tesis doctoral para una explicación más detallada (Capítulo \ref{c4}).

%dominio y navegación

\subsubsection{Generación de los Modelos Conceptuales a nivel PIM}\label{reglas}

Definidos los requisitos en un CIM, el siguiente paso consiste en utilizarlos para derivar la estructura de los modelos conceptuales de la aplicación Web. Para lograrlo, es necesario que los modelos cumplan con la sintaxis abstracta de un dominio especifico, es decir, que sean conformes a un metamodelo. A continuación se describen los metamodelos utilizados para la derivación de los modelos conceptuales a nivel PIM de MDA.

UML (\emph{Unified Modeling Language}) \cite{UML} es un el lenguaje de modelado estándar utilizado para la derivación del modelo de dominio de A-OOH. El metamodelo describe los objetos, atributos y relaciones necesarias para representar los conceptos de UML dentro de una aplicación de \emph{software}. Los modelos estáticos son presentados en diagramas llamados Diagramas de Clases. El propósito de un diagrama de clase es representar a las clases dentro de un modelo. En una aplicación orientada a objetos, las clases tienen atributos (variables miembros), operaciones (funciones miembro) y relaciones con otras clases. Estas características aplican perfectamente para la representación del modelo de dominio de A-OOH.

Por otra parte, A-OOH dispone de un metamodelo \cite{irene08} para representar las rutas de navegación que el usuario puede seguir durante su interacción con la aplicación Web. En la Figura \ref{fig:NavMetamodel} se muestra el metamodelo de navegación utilizado en A-OOH. Los elementos principales del metamodelo son: (i) Nodo Navegacional (\emph{Navigational Node}) y (ii) Enlace Navegacional (\emph{Navigational Link}).

%\begin{figure}
%\begin{center}
%\includegraphics[width=\textwidth]{img/NavigationalMetamodelFormal.eps}
%\end{center}
%\caption{Definición del metamodel de navegación en A-OOH.}
%\label{fig:navmetamodel}
%\end{figure}
\begin{landscape}
\begin{figure}
\begin{center}
\includegraphics[width=1.5\textwidth]{img/NavigationalMetamodel.png}
\end{center}
\caption{Metamodelo de Navegación de A-OOH.}
\label{fig:NavMetamodel}
\end{figure}
\end{landscape}


El Nodo Navegacional representa vistas restringidas de los conceptos del dominio y sus relaciones indican las rutas de navegación que el usuario de la aplicación Web puede seguir. Existen tres tipos diferentes de Nodos Navegacionales, los cuales se describen a continuación:

\begin{itemize}
\item \textbf{Clases de Navegación} (\emph{Navigational Classes}), son clases del dominio enriquecidas con atributos y métodos cuya visibilidad ha sido restringida, dependiendo de los permisos de acceso del usuario y de los requisitos de navegación. Es representada por una clase UML estereotipada como \emph{NavigationalClass}.

\item \textbf{Objetivos de Navegación} (\emph{Navigational Targets}), agrupan los elementos del modelo que colaboran en el cumplimiento de cada requisito de navegación del usuario. Son representados utilizando la notación UML de paquetes con el estereotipo \emph{NavigationalTarget}.

\item \textbf{Colecciones} (\emph{Collections}), son estructuras jerárquicas definidas en Clases Navegacionales u Objetivos Navegacionales. Proveen al usuario de la aplicación Web nuevas formas de accesar a la información. La colección más común es \emph{C-Collection} (\emph{Clasifier Collection}), la cual actúa como un mecanismo de abstracción para el concepto de menú, agrupa de esta forma Enlaces Navegacionales (\emph{Navigational Links}). Otra colección importante es la llamada \emph{S-Collection} (\emph{Selector Collection}) mediante la cual podemos representar un mecanismo de selección. Las colecciones son representadas por medio de una clase UML estereotipada como \emph{NavigationalC-Collection} o \emph{NavigationalS-Collection}.
\end{itemize}

El Enlace Navegacional define las rutas de navegación que el usuario puede seguir a través de la aplicación Web. A-OOH en su metamodelo de navegación define dos tipos principales de enlaces (\emph{links}):

\begin{itemize}
\item \textbf{T-Links} (\emph{Transversal Links}), son enlaces definidos entre dos nodos navegacionales (clases navegacionales, colecciones u objetivos navegacionales). La navegación es realizada para mostrar información a través de la interfaz del usuario sin modificar en absoluto la lógica de negocio. Estos tipos de enlaces son representados por el estereotipo \emph{TransversalLink}.

\item \textbf{S-Link} (\emph{Service Links}), con estos tipos de enlaces la navegación es realizada para activar una operación, la cual, en forma opuesta a los \emph{T-Links} modifica la lógica del negocio y además implica que la navegación a un nodo muestre información cuando termine la ejecución del servicio. Se establece cuando un servicio de la clase navegacional es activado. Estos tipos de ligas son representados por el estereotipo \emph{ServiceLink}  y tiene asociado el nombre del servicio que lo invoco.
\end{itemize}


%Un modelo representa algún aspecto de un sistema \emph{software} y conforma con el metamodelo con el que está expresado. Una vez se han presentado y descrito los metamodelos utilizados por A-OOH se procederá a explicar la derivación de los modelos conceptuales de dominio y navegación.

El modelo de dominio en A-OOH encapsula la estructura y funcionalidad de los conceptos relevantes del dominio de la aplicación Web y también refleja la parte estática de la misma, se representa como un diagrama de clases en notación UML \cite{UML}. El objetivo consiste en obtener el esqueleto del modelo de dominio de A-OOH a partir del modelo de requisitos en \emph{i*} por medio de un conjunto de reglas de transformación descritas formalmente en QVT \cite{OMG/QVT} (ver Capítulo \ref{4} y Apéndice \ref{a3}). 

%Con las reglas, se obtendrá un modelo de \emph{weaving} para mantener enlaces bidireccionales entre los elementos de ambos modelos (a nivel de sus respectivos elementos). A continuación se describen las principales reglas QVT para generar el modelo de dominio y el modelo de \emph{weaving}:

\begin{itemize}
\item \textbf{\emph{Content2DomainClass}}. El dominio origen de la relación está compuesto por un conjunto de elementos que representan un requisito del tipo \emph{Content}. Cuando se detecta este patrón en el modelo de entrada se fuerza la creación de una clase tipo \emph{Class UML} en el modelo destino (modelo de dominio). Por tanto, por cada requisito de contenido, se obtiene una clase en el modelo de dominio (Figura \ref{fig:content2Domain}).

\begin{figure}
\begin{center}
\includegraphics[width=0.8\textwidth]{img/content2domainclass.eps}
\end{center}
\caption{Regla QVT para obtener las clases del modelo de dominio.}
\label{fig:content2Domain}
\end{figure}

\item \textbf{\emph{Service2Operation}}. La regla detecta un conjunto de elementos en el modelo de entrada (modelo de requisitos) que corresponden con un requisito \emph{Service} asociado a un requisito \emph{Content}. Una vez detectado este patrón de elementos, se crea en el modelo de salida (modelo de dominio) una clase \emph{Operation} en la clase del modelo de dominio correspondiente (Figura \ref{fig:service2operation}).
\begin{figure}
\begin{center}
\includegraphics[width=0.8\textwidth]{img/service2operation.eps}
\end{center}
\caption{Regla QVT para obtener las clases del modelo de dominio.}
\label{fig:service2operation}
\end{figure}
\item \textbf{\emph{Navigation2Relationship}}. Esta relación permite crear asociaciones entre clases en el modelo de dominio. Existen dos requisitos \emph{Content} como origen, si los dos requisitos se usan para cumplir el mismo requisito de navegación, entonces se crea una clase \emph{Association} entre las clases del modelo de dominio que las representan (Figura \ref{fig:navigation2relationship}).
\begin{figure}
\begin{center}
\includegraphics[width=0.8\textwidth]{img/navigation2relationship.eps}
\end{center}
\caption{Regla QVT para obtener las relaciones entre las clases del modelo de dominio A-OOH.}
\label{fig:navigation2relationship}
\end{figure}
\end{itemize}


Como se mencionó anteriormente, el modelo de navegación está compuesto de nodos navegacionales y sus respectivas relaciones para indicar las rutas de navegación de la aplicación Web. Para derivar el modelo de navegación los requisitos tomados en cuenta para generar un conjunto de reglas de transformación QVT son los requisitos de contenido (\emph{Content}), servicio (\emph{Service}), navegación (\emph{Navigational}) y personalización (\emph{Personalization}). En este caso, las reglas QVT para la obtención del modelo de navegación son las siguientes:


\begin{itemize}
\item \textbf{\emph{Navigation2NavClass}}. Esta regla de transformación detecta cada requisito navegacional, derivando su correspondiente clase. En concreto, cuando se detecta en el modelo origen un requisito \emph{Navigational} unido a un requisito \emph{Content}, entonces se crea una clase estereotipada como \emph{NavigationalClass} en el modelo destino. Además cada una de las nuevas clases es el destino de una nueva asociación \emph{TransversalLink} desde una \emph{C-Collection} previamente creada por la función \emph{createMenu} que se encuentra en la cláusula \emph{when} (Figura \ref{fig:nav2navclass}).
\begin{figure}
\begin{center}
\includegraphics[width=0.6\textwidth]{img/navigation2relationship.eps}
\end{center}
\caption{Regla QVT para obtener las clases navegacionales.}
\label{fig:nav2navclass}
\end{figure}

\item \textbf{\emph{Personalization2NavClass}}. La regla es similar a la anterior pero detectando los requisitos de personalización que tienen un requisito de contenido asociado. Se derivan en el modelo de navegación los mismos elementos que en la regla anterior.


\item \textbf{\emph{Navigation2TransversalLink}}. Permite crear asociaciones entre clases navegacionales en el modelo de navegación. Existen dos modelos origen con el fin de detectar requisitos \emph{Content}, si los dos requisitos se usan para cumplir con el mismo requisito de navegación (comprobado en la cláusula \emph{when} con la operación \emph{SameNavigationOrigin)}, entonces se crea una asociación \emph{TransversalLink} entre las clases del modelo de navegación que las representan.

\item \textbf{\emph{Service2ServiceAndSLink}}. La relación detecta un conjunto de elementos en el modelo origen que corresponden con un requisito \emph{Service} asociado a un requisito \emph{Content}. Una vez detectado este patrón de elementos, se crea en el modelo destino una clase \emph{Operation} en la clase del modelo de navegación correspondiente. Además, se crea una asociación \emph{ServiceLink} para cada operación añadida. El nuevo enlace de servicio se asocia a una nueva clase navegacional (\emph{NavigationalClass}) destino. Antes de ejecutarse la transformación, se debe verificar que se cumple con las sentencias dispuestas en la cláusula \emph{when}, en este caso \emph{Navigation2NavClass} y \emph{Personaliza tion2NavClass}, con el fin de crear en el modelo destino todas las posibles clases de navegación a partir de cada uno de los requisitos \emph{Content} en el modelo origen.


\end{itemize}

Finalmente, es importante mencionar que los modelos conceptuales derivados son modelos iniciales que servirán como punto de partida para el diseñador Web, de esta forma es posible proveer un alto grado de automatización en el proceso de desarrollo de aplicaciones Web dirigido por modelos.

\subsection{Gestión de Requisitos en A-OOH}
\label{c1:gestion}

El uso de técnicas orientadas a objetivos para la especificación de requisitos en ingeniería Web permite reflejar desde las etapas iniciales del proceso de desarrollo los objetivos, tareas y relaciones de los \emph{stakeholder's}, lo que proporciona los elementos necesarios para que se consideren las necesidades y objetivos del usuario de la aplicación Web. Sin embargo, a pesar de que los requisitos son especificados en un modelo conceptual, los \emph{stakeholder's} necesitan observar que han sido reflejados correctamente en la aplicación Web final. Una forma de brindar soporte a esta necesidad es proveer al diseñador Web con una etapa de requisitos que consideré la gestión de los mismos. 

Por tanto, la propuesta presentada en la tesis se ha extendido para proveer al diseñador con soporte para: (i) trazabilidad de requisitos (CIM-PIM) \cite{aguilarDSDM}, (ii) evaluar el impacto derivado de un cambio en los modelos conceptuales (análisis de impacto) \cite{AguilarICCSA} y (iii) alternativas de diseño considerando la maximización y/o balance de los requisitos no-funcionales \cite{AguilarWISM}.

\subsubsection{Trazabilidad de Requisitos en A-OOH}
\label{c1:trazabilidad}

En el campo de la ingeniería Web dirigida por modelos, realizar el seguimiento de los requisitos durante la etapa de desarrollo de la aplicación Web hasta su implementación final es una tarea compleja \cite{AguilarICCSA}. Esto se debe a que en ingeniería Web se deben generar varios modelos conceptuales a partir de los requisitos como son el modelo de dominio o de navegación. Además, debido al desarrollo gradual de las necesidades de los usuarios de una aplicación Web, estos modelos cambian constantemente por lo que la trazabilidad de los requisitos se hace indispensable.

La trazabilidad de requisitos se define como la capacidad de describir y seguir la vida de un requisito, en ambas direcciones \cite{gotel1994analysis}: (i) determinar qué partes del modelo están relacionadas con cada uno de los requisitos, y (ii) determinar qué requisitos dieron origen a qué partes del modelo. En la actualidad, existen dos estrategias para gestionar y almacenar la información para la trazabilidad entre modelos: (i) la información se puede integrar en los modelos a los que se refiere y (ii) la información de trazabilidad se puede almacenar por separado en otro modelo \cite{barbero2007traceability}. La primera de estas dos opciones tiene como desventaja que si la información es almacenada en el mismo modelo, el modelo será contaminado con información poco relevante para el contexto del modelo y por lo tanto, será difícil de mantener y utilizar. Por otro lado, la segunda estrategia consiste en almacenar la información en un modelo aparte. De esta forma se pueden corregir las desventajas mencionadas.

Con el fin de brindar soporte para la trazabilidad de requisitos en A-OOH \cite{aguilarDSDM} se ha utilizado el concepto de modelo de \emph{weaving}. Un modelo de \emph{weaving} es un tipo de modelo formado por enlaces y referencias a elementos, los enlaces están dirigidos a las referencias de los elementos de un modelo origen y de un modelo destino. A continuación, se presenta el metamodelo base para \emph{weaving} \cite{del2006weaving} y una extensión para proveer a dicho metamodelo con elementos útiles para representar la trazabilidad entre modelos \cite{barbero2007traceability}. El metamodelo se muestra en la Figura \ref{fig:weavingmetamodel}:

\begin{itemize}
\item \textbf{\emph{WElement}}. Es el elemento base del cual los seis elementos restantes heredan, esta formado por los atributos nombre y descripción.
\item \textbf{\emph{WModel}}. Representa el elemento raíz que contiene a todos los elementos del modelo. Está compuesto por las referencias y relaciones a los modelos de entrada y salida.
\item \textbf{\emph{WLink}}. Sirve para representar un enlace entre los elementos del modelo.
\item \textbf{\emph{WLinkEnd}}. Este elemento representa el extremo final de un enlace.
\item \textbf{\emph{WElementRef}}. Este elemento se asocia a una función de identificación, creando un identificador único para cada elemento del modelo ligado, por tanto WElementRef permite referenciar el mismo elemento del modelo enlazados por diversos elementos WLinkEnd.
\item \textbf{\emph{WModelRef}}. Representa un identificador único de un modelo.
\end{itemize}

%\begin{landscape}
\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/WeavingMetamodel.png}
\end{center}
\caption{Metamodelo de \emph{weaving}.}
\label{fig:weavingmetamodel}
\end{figure}
%\end{landscape}


Por otra parte, en la Figura \ref{fig:tracemetamodel}, se ilustra la extensión del metamodelo para \emph{weaving} que permite la representación de la trazabilidad. Esta extensión la forman los siguientes elementos:

\begin{itemize}
\item \textbf{\emph{TraceModel}}. Es el elemento que representa al modelo de trazabilidad, esta integrado por referencias a otros modelos.
\item \textbf{\emph{TraceModelRef}}. Representa la referencia a otros modelos, es decir, es un único identificador para los modelos que conforman el modelo de trazabilidad.
\item \textbf{\emph{ElementRef}}. Es un identificador para señalar cada elemento que integran los modelos ligados.
\item \textbf{\emph{TraceLink}}. Un enlace de rastreo, utilizado para representar las correspondencias entre las referencias de los elementos de los modelos enlazados. Como información de trazabilidad, almacena el nombre de la regla de transformación que ha sido ejecutada.
\item \textbf{\emph{TraceLinkEnd}}. Su función es similar al elemento WLinkEnd del cual hereda, pues permite crear una relación uno a muchos (1-N) entre las referencias de los elementos del modelo de entrada (\emph{sourceElements}) y los del modelo de salida (\emph{targetElement}).
\end{itemize}

%\begin{landscape}
\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/TraceabilityMetamodel.png}
\end{center}
\caption{Extensión del metamodelo de \emph{weaving} para trazabilidad.}
\label{fig:tracemetamodel}
\end{figure}
%\end{landscape}

De esta forma se ha definido formalmente la regla de transformación \emph{CreateModelTrace} para derivar enlaces \emph{weaving} que almacene un conjunto de enlaces dirigidos a los elementos de los modelos conceptuales de A-OOH. La regla ha sido definida formalmente con el lenguaje estándar QVT.%(Figura \ref{fig:createModelTrace}).

\begin{itemize}
\item \textbf{\emph{CreateModelTrace}}. Al ejecutarse por primera vez, la regla crea un modelo de \emph{weaving} con referencias a los modelos origen y destino. De esta forma, cada vez que una regla QVT transforma un elemento del modelo de entrada (modelo de requisitos) en uno o varios elementos de los modelos conceptuales A-OOH (dominio y navegación) crea un nuevo enlace en el modelo de \emph{weaving}.
\end{itemize}

%\begin{figure}
%\begin{center}
%\includegraphics[width=\textwidth]{img/content2domainclass.eps}
%\end{center}
%\caption{Regla QVT para obtener el modelo de \emph{weaving}.}
%\label{fig:createModelTrace}
%\end{figure}


\subsubsection{Análisis de Impacto en A-OOH}
\label{c1:analisisimpacto}

Los requisitos evolucionan constantemente a razón de la naturaleza dinámica de la Web. Debido a esto, es común encontrar inconsistencias entre los modelos conceptuales de la aplicación Web y los requisitos. Una de las ventajas ofrecidas por el soporte para trazabilidad en A-OOH es el de conocer las dependencias entre los elementos de los modelos conceptuales y los requisitos. Por tanto, es posible conocer los requisitos afectados debido a un cambio en alguno de los modelos conceptuales. Análisis de impacto, conocido también como (\emph{Change Impact Analysis}), es la tarea de identificar las consecuencias potenciales de un cambio o estimar qué es necesario modificar para llevar a cabo el cambio \cite{impact}. Comúnmente, el análisis de impacto se ha realizado de forma intuitiva por los diseñadores de la aplicación Web por medio de un análisis superficial del código y documentación de la aplicación. Esto quizá sea suficiente para aplicaciones Web no muy grandes, pero no es suficientes para aplicaciones Web sofisticadas. Asímismo, investigación empírica demuestra que, incluso los desarrolladores más experimentados deducen un análisis de impacto incompleto \cite{Lindvall}.

Para paliar esta limitante, se ha definido un algoritmo para analizar las dependencias entre los requisitos funcionales. El algoritmo analiza el modelo de requisitos A-OOH para conocer las dependencias entre los requisitos funcionales además de saber qué requisitos no funcionales se ven afectados. De esta forma, a través del soporte para trazabilidad es posible conocer que otros elementos de los modelos conceptuales son afectados. Finalmente, debido a que el modelo de requisitos A-OOH es orientado a objetivos \cite{AguilarJUCS,Garrigos09}, el algoritmo puede mostrar al diseñador un camino alternativo en el cual se indique qué requisitos tienen que ser implementados para seguir cumpliento con el objetivo (\emph{Goal}). A continuación se presenta un ejemplo de la aplicación del algoritmo.

Supongamos que el cliente ha solicitado la implementación de una aplicación Web que permita la aplicación de encuestas \emph{on-line}. En primer lugar es necesario que el diseñador especifique los requisitos de la aplicación Web, para esta demostración, solo se ha definido el actor que representa a la aplicación Web (Figura \ref{fig:req1iccsa}). 

\begin{figure}
\begin{center}
\includegraphics[width=0.8\textwidth]{img/EjemploICCSA.png}
\end{center}
\caption{El modelo de requisitos de la aplicación \emph{``Survey WebApp''}.}
\label{fig:req1iccsa}
\end{figure}

El actor ``\emph{Survey WebApp}'' tiene que cumplir con el objetivo ``\emph{Survey be performed}'', para lograrlo dispone de dos vías, por medio de la aplicación de la encuesta pública ``\emph{Public survey}'' o la privada ``\emph{Private survey}'', ambos requisitos de navegación. Cada una de las vías necesita de uno o más requisitos para cumplirse, tal es el caso del requisito ``\emph{Private survey}'' debido a que necesita de los requisitos de navegación ``\emph{Make private survey}'' y ``\emph{Viewsurvey}'' así como del requisito de contenido ``\emph{Registered users}''. Algunos de los requisitos afectan positiva o negativamente a los requisitos no-funcionales especificados, por ejemplo, el requisito navegacional ``\emph{Private survey}'' afecta positivame al requisito no-funcional ``\emph{Security}''. El tipo de contribuciones que realizan los requisitos funcionales a los requisitos no-funcionales es relevante para la ejecución del algoritmo ya que son utilizadas para decidir qué requisitos funcionales será necesario implementar. En este ejemplo, solo los requisitos relacionados con el requisito de navegación ``\emph{Public survey}'' se encuentran implementados en los modelos conceptuales (Figura \ref{fig:req1iccsaIniciales}). 

\begin{figure}
\begin{center}
\includegraphics[width=0.8\textwidth]{img/EjemploICCSAReqIniciales.png}
\end{center}
\caption{Requisitos de la aplicación \emph{``Survey WebApp''} implementados inicialmente.}
\label{fig:req1iccsaIniciales}
\end{figure}

Ahora bien, supongamos el siguiente escenario: el desarrollador Web elimina un elemento del modelo de dominio A-OOH, gracias al soporte para trazabilidad de A-OOH es posible conocer el requisito afectado por la clase del modelo de dominio que ha sido eliminada, la clase corresponde con el requisito navegacional ``\emph{Public survey}''. Por tanto, el objetivo ``\emph{Survey be performed}'' no se puede cumplir. Por tal motivo, es necesario conocer:
\begin{itemize}
	\item ¿Cuáles requisitos son afectados por este cambio en el modelo de requisitos?
	\item ¿Cuáles elementos de los modelos conceptuales son afectados?
\end{itemize}
Por último, es necesario encontrar un camino alternativo en el modelo de requisitos (si es que existe) para continuar cumpliendo con el objetivo ``\emph{Survey be performed}''.

El algoritmo inicia una vez que se han cumplido un conjunto de pre-condiciones, las cuales pueden consultarse con detalle en el Capítulo \ref{c5}. El primer paso del algoritmo consiste en realizar un listado de todos aquellos requisitos funcionales que se encuentren implementados o no (en este caso, reflejados en el modelo de dominio), y que además realicen alguna contribución positiva o negativa a cualquier requisito no-funcional, el listado quedará como lo muestra la Tabla \ref{tab:listaElementosIntencionales}. El requisito afectado se muestra resaltado en negritas. Con el listado generado y el soporte para trazabilidad de A-OOH es posible saber qué elementos del modelo conceptual de dominio resultan afectados por la eliminación del requisito navegacional ``\emph{Public survey}''.

\begin{table}
 \centering
%\tiny %\addtolength{\tabcolsep}{-5pt}
 \caption{La contribución de los requisitos funcionales a cada requisito no-funcional.}\label{tab:listaElementosIntencionales}
\begin{tabular}{| l | c| c | c |}
\hline
\textbf{Requirements} &
\textbf{\emph{``Process easier''}} &
\textbf{\emph{``Complete info''}} &
\textbf{\emph{``Security''}}
\\
\hline
  \textbf{\emph{``Public Survey''}} & \textbf{Help} & \textbf{-} & \textbf{Hurt} \\
  \emph{``Make Survey''} & - & Break & - \\
  \emph{``Private Survey''} & Some- & - & Some+ \\
  \emph{``Send Survey''} & - & - & Some-\\
  \emph{``View Surveys''} & - & Make & -\\
  \emph{``Send Private Survey''} & - & - & Help \\
\hline
\end{tabular}
\end{table}

El siguiente paso consiste en determinar un camino alternativo para la satisfacción del objetivo de la aplicación (``\emph{Survey be performed}''). Por cada requisito no-funcional que recibe una contribución por parte del requisito a remover (Tabla \ref{tab:listaElementosIntencionales}) es necesario buscar un requisito no implementado del cual su contribución compense la eliminación del requisito a remover. En este caso, el requisito navegacional \emph{``Private Survey''} realiza dos contribuciones a los requisitos no-funcionales \emph{``Process easier''} y\emph{``Security''}, por lo tanto se puede implementar. Para poder determinar si el requisito se puede implementar o no, es necesario aplicar un conjunto de heurísticas (Capítulo \ref{c5}). El requisito navegacional \emph{``Private Survey''} se puede implementar gracias a las heurísticas número 2 y 3. Este paso es iterativo y finaliza cuando no hay más requisitos (no implementados) que realicen contribuciones a los requisitos no-funcionales. El paso finaliza cuando es detectado el requisito navegacional \emph{``Send Private Survey''}. 

Finalmente, es necesario aplicar una post-condición, la cual establece que si los requisitos a implementar (\emph{``Private Survey''} y \emph{``Send Private Survey''}) tienen uno o más requisitos asociados, estos requisitos deben ser implementadas de forma automática. Por tanto, los requisitos \emph{``View Surveys''} y \emph{``Registered Users''} deben de ser implementados. En la Figura \ref{fig:req2iccsa} se muestran los requisitos a implementar.


\begin{figure}
\begin{center}
\includegraphics[width=0.8\textwidth]{img/EjemploICCSAReqFinales.png}
\end{center}
\caption{Los nuevos requisitos a implementar en el modelo de dominio.}
\label{fig:req2iccsa}
\end{figure}


\subsubsection{Optimización de Requisitos No-Funcionales en Aplicaciones Web}
\label{c1:optimizacion}

Como se ha motivado anteriormente, las aplicaciones Web tienen una audiencia amplia y heterogénea \cite{aguilarDSDM, irene08}, por eso es indispensable que las metodologías de diseño brinden soporte al diseñador en la etapa de requisitos y le permitan seleccionar distintas opciones de diseño en base la audiencia de la aplicación Web. 

En A-OOH se ha implementado el algoritmo Frontera de Pareto \cite{Pareto1} para proveer al diseñador con un conjunto de alternativas de diseño basadas en la prioridad de los requisitos no-funcionales. Para esto, el diseñador establecerá una lista de requisitos no-funcionales, a continuación, el algoritmo obtendrá todas las posibles configuraciones de entre las cuales el diseñador seleccionará aquella que maximice o balancee los requisitos no-funcionales establecidos previamente (Figura \ref{fig:ParetoApproach}). Asímismo, se han definido una serie de pasos con el fin de satisfacer los objetivos definidos en el modelo de requisitos (\emph{Goals}).

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/ParetoApproach.png}
\end{center}
\caption{Propuesta para la optimización de requisitos no-funcioales en aplicaciones Web.}
\label{fig:ParetoApproach}
\end{figure}

La Frontera de Pareto es una temática que proviene del estudio de la economía y ha sido ampliamente aplicada en la ingeniería de \emph{software}, en este caso en particular lo enunciamos como: ``\emph{Dado un conjunto de ubicaciones alternativas y un conjunto de individuos, la ubicación A es una optimización sobre la ubicación B solo si A puede al menos, optimizar a un individuo mejor que B, sin deteriorar a otro individuo}'' \cite{Pareto2,Pareto1}. Por lo tanto, llamamos configuración óptima de Pareto a aquella configuración que mejor satisfaga a un requisito no-funcional mientras satisface a los demás de igual forma. Las configuraciones las constituyen el conjunto de requisitos funcionales que pueden ser implementados en la aplicación Web. El conjunto de soluciones óptimas de Pareto puede ser utilizado por el diseñador para la toma de decisiones, por ejemplo, cuando necesite seleccionar la configuración que mejor balancee la compensación entre los requisitos no-funcionales y cuando necesite considerar la maximización sobre un requisito no-funcional en particular.

A continuación, se presenta un ejemplo consiso para ejemplificar paso a paso la aplicación de la propuesta para la optimización de requisitos no-funcionales en aplicaciones Web. El caso de estudio es acerca de una aplicación Web para la gestión de conferencias (\emph{Conference Management System})\footnote{La especificación completa del caso de estudio se encuentra en \url{http://users.dsic.upv.es/~west/iwwost01}}. El porpósito de la aplicación Web es brindar soporte al proceso de envío, evaluación y selección de los artículos para una conferencia. La Figura \ref{fig:CasoEstudioWISM}, muestra la especificación de requisitos de la aplicación Web (modelo de requisitos de A-OOH). El objetivo de la aplicación Web consiste en ``\emph{Process of review of papers be selected}'', para satisfacer el objetivo, es necesario la implementación de alguno de los requisitos navegacionales ``\emph{Blind review process}'' y ``\emph{Normal review process}''. En este ejemplo el objetivo es logrado a través del requisito navegacional ``\emph{Blind review process}''. En la especificación de requisitos, también se puede observar que algunos requisitos necesitan de otros para poder cumplir con su función, tal es el caso del requisito navegacional ``\emph{Review paper}'' el cual necesita del requisito de servicio ``\emph{Submit review}''. Además, algunos requisitos afectan de forma positiva o negativa a algunos requisitos no-funcionales (llamados \emph{Softgoals} de aquí en adelante), por ejemplo el requisito de servicio ``\emph{Download paper without author's name}'' afecta de forma positiva a la \emph{Softgoal} ``\emph{Privacy be maximized}'' y de forma negativa a ``\emph{Obtain more complete info}''. Las contribuciones de los requisitos funcionales a las \emph{Softgoals} pueden verse en la Tabla \ref{tab:contribuciones}.

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/CasoEstudioWISM.png}
\end{center}
\caption{Especificación de requisitos de la aplicación Web para la gestión de conferencias.}
\label{fig:CasoEstudioWISM}
\end{figure}

\begin{table}
 \centering
 \small
 \caption{Tipos de contribuciones.}\label{tab:contribuciones}
\begin{tabular}{|l | c |}
\hline
\textbf{Contribución} & \textbf{Tipo de Contribución} \\
\hline
Positiva& Help \\
Positiva de fuerza desconocida & Some + \\
Negativa & Hurt \\
Negativa de fuerza desconocida & Some - \\
Negativa suficiente para no satisfacer una \emph{Softgoal}& Break \\
Positiva suficiente para satisfacer una \emph{Softgoal} & Make \\
\hline
\end{tabular}
\end{table}

Una vez especificados los requisitos de la aplicación Web, es necesario elaborar una lista que contenga a los requisitos (implementados o no) que realicen algún tipo de contribución a alguna \emph{Softgoal}. La Tabla \ref{tab:listaElementosIntencionales}, muestra una lista de requisitos y el tipo de contribución (Tabla \ref{tab:contribuciones}) hacia las \emph{Softgoal}, en donde: S1 se refiere a la \emph{Softgoal} \emph{``Be fair in review''}, S2 corresponde a \emph{``Review process easier''}, S3 a la \emph{Softgoal} \emph{``Accurate review process''}, S4 a \emph{``Privacy be maximized''}, S5 \emph{``Avoid possible conflicts of interest''} y S6 a la \emph{Softgoal} \emph{``Obtain more complete info''}.

\begin{table}
 \centering
\small %\addtolength{\tabcolsep}{-5pt}
 \caption{Las contribuciones de los requisitos hacia las \emph{Softgoals}.}\label{tab:listaElementosIntencionales}
\begin{tabular}{| l | c| c | c | c | c | c |}
\hline
\textbf{Requisitos} &
\textbf{\emph{``S1''}} &
\textbf{\emph{``S2''}} &
\textbf{\emph{``S3''}} &
\textbf{\emph{``S4''}} &
\textbf{\emph{``S5''}} &
\textbf{\emph{``S6''}}
\\
\hline
  \emph{``Blind review process''} & Help & Break & Hurt & Help & - & -\\
  \textbf{\emph{``Download papers without authors' name''}} & \textbf{-} & \textbf{-} & \textbf{-} & \textbf{-} & \textbf{Help} & \textbf{Some -}\\
  \emph{``Normal review process''} & Some - & Make & Help & - & - & -\\
  \emph{``Download paper with author's name''} & - & - & - & Hurt & Some - & Help\\
  \emph{``View review process status''} & - & - & - & - & - & Help\\
\hline
\end{tabular}
\end{table}

A continuación, es necesario almacenar cada configuración posible de los requisitos listados en la Tabla \ref{tab:listaElementosIntencionales}, en donde: la variable ``I'' representa el estado ``implementado'' y la variable ``N'' el estado ``no implementado''. Por lo tanto, tenemos 32 posibles configuraciones (Tabla \ref{tab:front}, columnas 1 y 2).

Además, es necesario asignar un peso a cada tipo de contribución, para esto, deben de asignarse por cada tipo el peso(W):  w= +1 si el tipo de contribución es  ``\emph{Help}'',  w= -1 si es ``\emph{Hurt}'', w= +2 para el tipo ``\emph{Some +}'' , w= -2 para ``\emph{Some -}'', w= +4 si es del tipo ``\emph{Make}'' y w= -4 para el tipo ``\emph{Break}''. 

%Por ejemplo, dada la matriz (\ref{mt:matriz}), tenemos que, para la fila 3 (requisito ``\emph{Normal review process}'') y columna 2 (\emph{Softgoal ``Review process easier''}) la matriz muestra '+4', es decir una contribución del tipo ``\emph{Make}'' si el requisito es implementado.

\begin{equation}
\small
M= 
\begin{pmatrix}
  \hfill {\color {black} +1} & \hfill {\color {red} -4} & \hfill{\color {red} -1} & {\color {black} 0} & \hfill {\color {black} +1} & {\color {black} 0}\\
  {\color {black} 0} & {\color {black} 0} & {\color {black} 0} & \hfill {\color {black} +1} & {\color {black} 0} & \hfill{\color {red} -2} \\
  \hfill{\color {red} -2} & \hfill {\color {black} +4} & \hfill {\color {black} +1} & {\color {black} 0} & {\color {black} 0} & {\color {black} 0} \\
  {\color {black} 0} & {\color {black} 0} & {\color {black} 0} & \hfill{\color {red} -2} & \hfill{\color {red} -1} & \hfill {\color {black} +1}\\
  {\color {black} 0} & {\color {black} 0} & {\color {black} 0} & {\color {black} 0} & {\color {black} 0} & \hfill {\color {black} +1} \\
\label{mt:matriz}
\end{pmatrix}
\end{equation}

Con los pesos establecidos, el siguiente paso consiste en crear una matriz para calcular los valores númericos asociados cada configuración (Tabla \ref{tab:front}, columnas 7 a 12), por ejemplo para la configuración X25, si el requisito R1 \emph{``Blind review process''} no es implementado, tenemos que la \emph{Softgoal} \emph{``Be fair in review''} será afectada (-2). Por último, se calcula si la configuración es Frontera de Pareto (Tabla \ref{tab:front}, columnas 13), para hacerlo, se deben comparar cada una de las configuraciones indicando si es que existe una que sea mejor que otra, por ejemplo, la configuración X3 está en la Frontera de Pareto por que es mejor que las configuraciones X1 y X2 debido a que maximiza al menos a un individuo, es decir, maximiza a la \emph{Softgoal} 5.


\begin{table}[!ht]
 \centering
\small%\tiny %\addtolength{\tabcolsep}{-5pt}
 \caption{The posible requirements to implement or not for the softgoal tradeoff.}\label{tab:front}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
\textbf{Configuración} & \textbf{R1} & \textbf{R2} & \textbf{R3} & \textbf{R4} & \textbf{R5} & \textbf{F(S1)} & \textbf{F(S2)} & \textbf{F(S3)} & \textbf{F(S4)} & \textbf{F(S5)} & \textbf{F(S6)} & \textbf{Pareto front}
\\
\hline
\textbf{X1} & I & I & I & I & I & -1 & 0 & 0 & -1 & 0 & 0 & No\\ %\rowcolor[rgb]{0.8,0.8,0.8}
\textbf{X2} & I & I & I & I & N & -1 & 0 & 0 & -1 & 0 & -1 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X3} & I & I & I & N & I & -1 & 0 & 0 & 1 & 1 & -1 & Yes\\
\textbf{X4} & I & I & I & N & N & -1 & 0 & 0 & 1 & 1 & -2 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X5} & I & I & N & I & I & 1 & -4 & -1 & -1 & 0 & 0 & Yes\\
\textbf{X6} & I & I & N & I & N & 1 & -4 & -1 & -1 & 0 & -1 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X7} & I & I & N & N & I & 1 & -4 & -1 & 1 & 1 & -1 & Yes\\
\textbf{X8} & I & I & N & N & N & 1 & -4 & -1 & 1 & 1 & -2 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X9} & I & N & I & I & I & -1 & 0 & 0 & -2 & 0 & 2 & Yes\\
\textbf{X10} & I & N & I & I & N & -1 & 0 & 0 & -2 & 0 & 1 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X11} & I & N & I & N & I & -1 & 0 & 0 & 0 & 1 & 1 & Yes\\
\textbf{X12} & I & N & I & N & N & -1 & 0 & 0 & 0 & 1 & 0 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X13} & I & N & N & I & I & 1 & -4 & -1 & -2 & 0 & 2 & Yes\\
\textbf{X14} & I & N & N & I & N & 1 & -4 & -1 & -2 & 0 & 1 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X15} & I & N & N & N & I & 1 & -4 & -1 & 0 & 1 & 1 & Yes\\
\textbf{X16} & I & N & N & N & N & 1 & -4 & -1 & 0 & 1 & 0 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X17} & N & I & I & I & I & -2 & 4 & 1 & -1 & -1 & 0 & Yes\\
\textbf{X18} & N & I & I & I & N & -2 & 4 & 1 & -1 & -1 & -1 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X19} & N & I & I & N & I & -2 & 4 & 1 & 1 & 0 & -1 & Yes\\
\textbf{X20} & N & I & I & N & N & -2 & 4 & 1 & 1 & 0 & -2 & No\\
\textbf{X21} & N & I & N & I & I & 0 & 0 & 0 & -1 & -1 & 0 & No\\
\textbf{X22} & N & I & N & I & N & 0 & 0 & 0 & -1 & -1 & -1 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X23} & N & I & N & N & I & 0 & 0 & 0 & 1 & 0 & -1 & Yes\\
\textbf{X24} & N & I & N & N & N & 0 & 0 & 0 & 1 & 0 & -2 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X25} & N & N & I & I & I & -2 & 4 & 1 & -2 & -1 & 2 & Yes\\
\textbf{X26} & N & N & I & I & N & -2 & 4 & 1 & -2 & -1 & 1 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X27} & N & N & I & N & I & -2 & 4 & 1 & 0 & 0 & 1 & Yes\\
\textbf{X28} & N & N & I & N & N & -2 & 4 & 1 & 0 & 0 & 0 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X29} & N & N & N & I & I & 0 & 0 & 0 & -2 & -1 & 2 & Yes\\
\textbf{X30} & N & N & N & I & N & 0 & 0 & 0 & -2 & -1 & 1 & No\\
\rowcolor[rgb]{0.8,0.8,0.8} \textbf{X31} & N & N & N & N & I & 0 & 0 & 0 & 0 & 0 & 1 & Yes\\
\textbf{X32} & N & N & N & N & N & 0 & 0 & 0 & 0 & 0 & 0 &  No\\
\hline
\end{tabular}
\end{table}

Finalmente, el último paso consiste en maximizar \emph{Softgoals} y continuar cumpliendo con el objetivo establecido en el modelo de requisitos (\emph{``Process of review papers be selected''}). Para esto, es necesario crear una lista de \emph{Softgoals} ordenadas por prioridad (Tabla \ref{tab:prioridad}). En base a la lista, se debe de seleccionar de la Tabla \ref{tab:front} las configuraciones que además de estar en la Frontera de Pareto cumplen con el objetivo, y de sta forma escoger la configuración que maximice las \emph{Softgoals}.

\begin{table}[!ht]
 \centering
\small%\tiny %\addtolength{\tabcolsep}{-5pt}
 \caption{Lista de \emph{Softgoals}.}\label{tab:prioridad}
\begin{tabular}{| c | c|}
\hline
\textbf{Prioridad} & \textbf{Softgoal}
\\
\hline
\textbf{1} & \emph{``S4.- Privacy be maximized''}  \\
\textbf{2} & \emph{``S2.- Review process easier''} \\
\textbf{3} & \emph{``S3.- Accurate review process''} \\
\textbf{4} & \emph{``S1.- Be fair in review''} \\
\textbf{5} & \emph{``S5.- Avoid possible conflicts os interest''}\\
\textbf{6} & \emph{``S6.- Obtain more complete info''}  \\
\hline
\end{tabular}
\end{table}

Para este ejemplo, ``X3'', ``X7'' y ``X17'' cumplen con el objetivo, de las tres configuraciones, la configuración X3 es la mejor opción, por que de acuerdo con la lista (Tabla \ref{tab:prioridad}), ``S4'' y ``S2'' son las \emph{Softgoals} a priorizar, por tanto, la configuración ``X17'' maximiza ``S2'', sin embargo afecta negativamente a la \emph{Softgoal} 4 (Tabla \ref{tab:front}). En cambio, la configuración ``X3'' maximiza a la \emph{Softgoal} ``S4'' (1) y no afecta a la \emph{Softgoal} ``S2'' (0).

\section{Una Propuesta para la Distribución de Requisitos en la Web 2.0: \emph{Rich Internet Applications}}
\label{c1:rias}

Una de las vertientes que ha tomado como base la investigación asociada a la tesis doctoral consiste en la evolución constante de las tecnología de implementación de las aplicaciones Web. En este campo encontramos a las RIAs (\emph{Rich Internet Applications}), las cuales nacen como una evolución natural de la Web, este tipo de aplicaciones hace frente a la limitación impuesta por la tecnología tradicional de la Web 1.0 \cite{cormode2008key} al ofrecer una serie de características especiales, por ejemplo interfaces más atractivas (ricas) y una mejor capacidad de respuesta e interactividad con el usuario (similar a la de aplicaciones de escritorio). Por último, en lo que respecta a tecnologías para al comunicación las RIAs ofrecen la posibilidad de comunicación por medio del audio y video (Figura \ref{fig:RiasDiagramaVenn})\footnote{Imágen tomada de \url{http://www.simonwhatley.co.uk/rich-internet-applications-a-background}}.

\begin{figure}
\begin{center}
\includegraphics[width=0.4\textwidth]{img/RiasDiagramaVenn.png}
\end{center}
\caption{Diagrama de Venn que ejemplifica las carácteristicas de las RIAs.}
\label{fig:RiasDiagramaVenn}
\end{figure}

Por otra parte, las RIAs son más difíciles de diseñar e implementar que las aplicaciones Web 1.0 debido a la funcionalidad que ofrecen. Por tal motivo, las metodologías para el desarrollo de aplicaciones Web han sido objeto de mejoras (adaptaciones en algunos casos) y han surgido nuevas aproximaciones específicamente para el desarrollo de RIAs \cite{Preciado}. Dentro del grupo de aproximaciones que han sido extendidas para el soporte de RIAs encontramos a OOHDM \cite{OOHDMRIA}, OOH con la extención OOH4RIAs \cite{OOH4RIAMethod}, UWE con las extensiones UWE-Patterns \cite{UWEpatterns4RIA}, UWE-R \cite{UWER} y UWE-RUX \cite{RUXMethod}, WebML \cite{Bozzon2008, Bozzon2006} y OOWS  \cite{Valverde2010}. Por otra parte, dentro del grupo de aproximaciones creadas exclusivamente para el desarrollo de RIAS encontramos a RUX-Model \cite{Preciado2008}, \emph{Internet Aplication Modeling Language} \cite{IAML} y ADRIA \cite{ADRIA2,ADRIA1}, para información más detallada sobre las aproximaciones tradicionales y las de nueva creación el lector puede consultar el apéndice \ref{a2}. La idea principal de las aproximaciones es brindar soporte a las características particulares de las RIAs, pero la mayoría de las metodologías se han enfocado principalmente en cuestiones de presentación \cite{RUXMethod, Preciado2007} y en capacidades de interacción \cite{OOH4RIAMethod} descuidando la etapa de análisis y especificación de requisitos. Esto es una desventaja muy importante a considerar, debido a que el diseñador tiene que lidiar con los requisitos de la Web 1.0, como lo es la navegación más los requisitos específicos de las RIAs, tales como, la capacidad de respuesta o la reducción del ancho de banda \cite{ReqForRIA}. Asimismo, el diseñador debe de considerar la distribución de los requisitos funcionales, es decir, si son implementados en el cliente o en el servidor y como es que la distribución afecta el cumplimiento de los requisitos no-funcionales. Por lo tanto, elegir dónde serán implementados los requisitos funcionales (cliente o servidor) es una decisión fundamental para el correcto desempeño de la RIA.

A continuación, se presenta una adaptación del trabajo presentado en la sección \ref{c1:optimizacion} para asistir al diseñador al momento de decidir sobre la distribución de los requisitos funcionales (Figura \ref{fig:overview}). El caso de estudio es acerca de una compañía de bioinformática la cual tiene como objetivo ofrecer servicios en línea sobre el análisis del genóma humano. La aplicación Web permitirá al usuario subir la información sobre un gen, analizar la información y obtener reportes personalizados. El primer y único servicio disponible para el usuario será el reporte de enfermedades al que es vunerable, para lograrlo, se comparará la información proporcionada por el usuario con la base de datos de genes de la compañía. La compañía, desea ofrecer una Web basada en RIA con la finalidad de ofrecer una aplicación Web lo suficientemente atractiva e interactiva para los usuarios. Por tal motivo, el equipo de desarrollo de la compañía quiere estudiar y analizar los beneficios que se obtendrán de la distribución de los requisitos funcionales entre el servidor y el cliente así como el impacto que tendrán en los requisitos no-funcionales, llamados \emph{softgoals} de aquí en adelante. Para efectos demostrativos, en el caso de estudio nos enfocaremos en los requisitos necesarios para el reporte de enfermedades.

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/OverviewRIAs.png}
\end{center}
\caption{Visión general de la propuesta para el análisis de requisitos RIA.} \label{fig:overview}
\end{figure}


El primer paso consiste en la especificación del modelo de requisitos base para RIAs por parte del diseñador. En él, el diseñador deberá especificar los objetivos, los requisitos funcionales y las \emph{softgoals} necesarias para modelar el reporte de enfermedades (Figura \ref{fig:baseRIA}).

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/EjemploRIAs.png}
\end{center}
\caption{Modelo de requisitos RIA base.} \label{fig:baseRIA}
\end{figure}

Debido a que aún no sabemos cuales requisitos serán ubicados de lado del cliente o de lado del servidor, las contribuciones por parte de los requisitos a las \emph{softgoals} son etiquetadas como ``\emph{unknown}''. En el particular caso de la \emph{softgoal} ``Compatibilidad'', las contribuciones recibidas por parte de los requisitos quedan establecidas en este paso debido a que no dependen del lugar donde se implementará el requisito (cliente o servidor). Las contribuciones originadas en el requisito ``Proporcionar interfaz gráfica'' también son etiquetadas debido a que el requisito solo puede ser implementado del lado del cliente.

El siguiente paso consiste en aplicar el algoritmo para obtener la eficiencia de Pareto. Primero es necesario identificar a los requisitos que realizan contribuciones a las \emph{softgoals}, no se deberá considerar el requisito ``Proporcionar interfaz gráfica'' por que, como lo mencionamos antes, solo es posible implementarlo del lado del cliente. La Tabla \ref{tab:softgoals-req} muestra los requisitos y \emph{softgoals} a utilizar.

\begin{table}
 \centering
 \caption{\emph{Softgoals} y Requisitos detectados en el modelo de requisitos RIA base.}\label{tab:softgoals-req}
\begin{tabular}{|l | l |}
\hline
\textbf{\emph{Softgoals}} & \textbf{Requisitos} \\
\hline
S1.- Seguridad & R1.- Proporcionar variaciones por enfermedad \\
S2.- Tiempo de respuesta & R2.- Proporcionar enfermedad por variante \\
S3.- Compatibilidad & R3.- Proporcionar PDF \\
S4.- Ancho de banda limitado & R4.- Proporcionar documento en formato propietario \\
\hline
\end{tabular}
\end{table}

El paso siguiente consiste en calcular todas las posibles configuraciones cliente/servidor, en donde C representa si el requisito se implementará en el Cliente y S si se implementará en el Servidor, como puede verse en la Tabla \ref{tab:front}, de la columna 2 a la columna 5. Después se deberán definir dos matrices (Matriz Cliente (\ref{mt:matriz}) y Matriz Servidor (\ref{mt:matrizServidor})) que representan la contribución de cada requisito a cada una de las \emph{softgoals}, por ejemplo, la fila 3 (requisito ``Proporcionar PDF''), columna 4 (\emph{softgoal} ``Tiempo de respuesta'') muestra +1 en la Matriz Cliente, por lo que es una contribución del tipo ``\emph{Help}'' si el requisito es implementado en el Cliente, en cambio, en la Matriz Servidor muestra -1, indicando una contribución del tipo ``\emph{Hurt}'' si el requisito se implementa en el Servidor. Con las matrices se calculará el resultado de las contribuciones de los requisitos a las \emph{Softgoals}, el cual es mostrado de la columna 6 a la columna 9 de la Tabla \ref{tab:front}. Por último, se indica si el vector de decisión esta en la frontera de Pareto (última columna).

\begin{equation}
%\tiny
M_{i_j}^k = 
\begin{pmatrix}
  \hfill {\color {red} -1} & \hfill {\color {black} +1} & \hfill{\color {black} 0} & {\color {black} 0} \\
  \hfill {\color {red} -1} & \hfill {\color {black} +1} & \hfill{\color {black} 0} & {\color {black} 0} \\
  \hfill {\color {red} -1} & \hfill {\color {black} +1} & \hfill{\color {black} +1} & {\color {red} -1} \\
  \hfill {\color {red} -1} & \hfill {\color {black} +1} & \hfill{\color {red} -1} & {\color {red} -1} \\
\label{mt:matriz}
\end{pmatrix}
\end{equation}

\begin{equation}
%\tiny
M_{i_j}^k = 
\begin{pmatrix}
  \hfill {\color {black} +1} & \hfill {\color {red} -1} & \hfill{\color {black} 0} & {\color {black} 0} \\
  \hfill {\color {black} +1} & \hfill {\color {red} -1} & \hfill{\color {black} 0} & {\color {black} 0} \\
  \hfill {\color {black} +1} & \hfill {\color {red} -1} & \hfill{\color {black} +1} & {\color {black} +1} \\
  \hfill {\color {black} +1} & \hfill {\color {red} -1} & \hfill{\color {red} -1} & {\color {black} +1} \\
\label{mt:matrizServidor}
\end{pmatrix}
\end{equation}

En la Tabla \ref{tab:front}, las filas de color gris son la Frontera de Pareto. El diseñador puede seleccionar la frontera de Pareto que mejor satisfaga las necesidades del \emph{stakeholder}, es decir, considerando las \emph{softgoals} de mayor interés. Por mencionar un ejemplo, tenemos que la configuración X1 (Tabla \ref{tab:front}) es la mejor opción si la \emph{softgoal} ``Tiempo de respuesta'' es la prioridad, en la solución cada requisito será implementado de lado del Cliente y de acuerdo con el resultado positivo de la columna 10 ($\Sigma$) las \emph{softgoals} restantes serán maximizadas o permanecerán igual, es decir, no serán afectadas negativamente. Por otro lado, la mejor opción respecto a la \emph{softgoal} ``Seguridad'' es la configuración X16 (Figura \ref{fig:X16}), de acuerdo con $\Sigma$ (-2), mejorar la seguridad afectará negativamente en algunas de las \emph{softgoals}. 

\begin{table}
\centering
%\tiny%\addtolength{\tabcolsep}{-5pt}
 \caption{La posible distribución de los requisitos entre el servidor y el cliente a través de la compensación de las \emph{softgoals}.}\label{tab:front}
    \begin{tabular}{|c|cccc|cccc|c|c|}
        \hline
        \textbf{Configuración}          & \textbf{R1} & \textbf{R2} & \textbf{R3} & \textbf{R4} & \textbf{F(S1)} & \textbf{F(S2)} & \textbf{F(S3)} & \textbf{F(S4)} & \textbf{$\Sigma$} & \textbf{Frontera de Pareto} \\ \hline 
        \rowcolor[rgb]{0.8,0.8,0.8}X1  & C          & C          & C          & C          & -4            & +4            & 0             & +2            & +2               & Si                         \\ \hline
        X2                             & C          & C          & C          & S          & -2            & +2            & 0             & 0             & 0                & No debido a X5             \\ \hline
        X3                             & C          & C          & S          & C          & -2            & +2            & 0             & 0             & 0                & No debido a X6             \\ \hline
        X4                             & C          & C          & S          & S          & 0             & 0             & 0             & -2            & -2               & No debido a X13            \\ \hline
        \rowcolor[rgb]{0.8,0.8,0.8}X5  & C          & S          & C          & C          & -2            & +2            & 0             & +2            & +2               & Si                         \\ \hline
        \rowcolor[rgb]{0.8,0.8,0.8}X6  & C          & S          & C          & S          & 0             & 0             & 0             & 0             & 0                & Si                         \\ \hline
        \rowcolor[rgb]{0.8,0.8,0.8}X7  & C          & S          & S          & C          & 0             & 0             & 0             & 0             & 0                & Si (como X6)               \\ \hline
        X8                             & C          & S          & S          & S          & +2            & -2            & 0             & -2            & -2               & No debido a X14            \\ \hline
        \rowcolor[rgb]{0.8,0.8,0.8}X9  & S          & C          & C          & C          & -2            & +2            & 0             & +2            & +2               & Si (como X5)               \\ \hline
        \rowcolor[rgb]{0.8,0.8,0.8}X10 & S          & C          & C          & S          & 0             & 0             & 0             & 0             & 0                & Si (como X6)               \\ \hline
        \rowcolor[rgb]{0.8,0.8,0.8}X11 & S          & C          & S          & C          & 0             & 0             & 0             & 0             & 0                & Si (como X6)               \\ \hline
        X12                            & S          & C          & S          & S          & +2            & -2            & 0             & -2            & -2               & No debido a X14            \\ \hline
        \rowcolor[rgb]{0.8,0.8,0.8}X13 & S          & S          & C          & C          & 0             & 0             & 0             & +2            & +2               & Si                         \\ \hline
        \rowcolor[rgb]{0.8,0.8,0.8}X14 & S          & S          & C          & S          & +2            & -2            & 0             & 0             & 0                & Si                         \\ \hline
        \rowcolor[rgb]{0.8,0.8,0.8}X15 & S          & S          & S          & C          & +2            & -2            & 0             & 0             & 0                & Si (como X14)              \\ \hline
        \rowcolor[rgb]{0.8,0.8,0.8}X16 & S          & S          & S          & S          & +4            & -4            & 0             & -2            & -2               & Si                         \\
        \hline
    \end{tabular}
\end{table}

\begin{landscape}
\begin{figure}
\begin{center}
\includegraphics[width=1.5\textwidth]{img/X16.png}
\end{center}
\caption{Configuración X16: distribución de los requisitos entre el cliente y el servidor.} \label{fig:X16}
\end{figure}
\end{landscape}

Por último, el resto de configuraciones de la frontera de Pareto (Tabla \ref{tab:front}) son configuraciones intermedias que estarán disponibles para que el diseñador pueda seleccionarlas de acuerdo a la compensación de \emph{softgoals} que necesite, por ejemplo, las configuraciones X6 y X14, ambas tienen $\Sigma$ = 0, por lo tanto, todas las \emph{softgoals} están balanceadas. En la configuración X14, los requisitos R1, R2 y R4 son ubicados en el servidor y R2 en el cliente, la solución quiza proporcione una buena compensación en caso de que la seguridad sea una prioridad por parte del \emph{stakeholder}, pero no se mejorarán el resto de \emph{softgoals}, incluso, la \emph{softgoal} `` Tiempo de respuesta'' será afectada negativamente.


\section{Implementación}
\label{c1:implementation}

La propuesta presentada en la tesis doctoral esta constituida dentro de MDA. Por lo tanto, para llevar a cabo la implementació ha sido necesaria combinación de un conjunto de tecnologías MDD entre las que destacan (i) la plataforma de desarrollo \emph{Eclipse}~\cite{ECLIPSE}, (ii) la tecnología EMF (\emph{Eclipse Modeling Framework}) \cite{EMF} y GMF (\emph{Graphical Modeling Framework}) \cite{GMF} y (iii) el lenguaje para transformaciones entre modelos ATL (\emph{Atlas Transformation Language}) \cite{ATL}. Cada una de las tecnologías utilizadas son descritas a continuación.



%La propuesta definida en esta tesis doctoral se ha implementado en la plataforma de desarrollo \emph{Eclipse}~\cite{ECLIPSE} utilizando tecnología EMF (\emph{Eclipse Modeling Framework}) (CITA) y GMF (\emph{Graphical Modeling Framework}) (CITA). \emph{Eclipse} puede extenderse por medio de \emph{plugins} con el fin de añadir más características y nuevas funcionalidades. Se ha desarrollado un \emph{plugin} que da soporte a cada parte de la propuesta. Este nuevo plugin contiene los siguientes módulos:

\begin{itemize}
   \item \textbf{\emph{Eclipse}}. Es un entorno de desarrollo integrado (\emph{Integrated Development Enviroment}, IDE) de código abierto multiplataforma, fue desarrollado originalmente por IBM\footnote{\url{http://www-01.ibm.com/software/rational/eclipse/}}. \emph{Eclipse} es ahora desarrollado por la Fundación \emph{Eclipse}, una organización independiente sin ánimo de lucro que fomenta una comunidad de código abierto. La característica principal de este IDE es que es  una plataforma de programación utilizada para crear entornos integrados de desarrollo puede extenderse por medio de \emph{plugins} con el fin de añadir más características y nuevas funcionalidades. 
	\item \textbf{\emph{Eclipse Modeling Framework}}. Es un marco de trabajo para modelado que ofrece facilidad de generación de código para construir herramientas y otras aplicaciones basadas en un modelo de datos estructurado. Desde una especificación del modelo descrita en XMI (XML de Intercambio de Metadatos), \emph{EMF} suministra herramientas y soporte en tiempo de ejecución para producir un conjunto de clases Java para el modelo, un conjunto de clases del tipo \emph{Adampter} que permiten visualización y edición basándose en comandos del modelo, y un editor básico. Los modelos pueden ser especificados usando anotación Java, documentos XML, o herramientas de modelado como \emph{Rational Rose}, y después ser importados a \emph{EMF}. Lo más importante de todo, \emph{EMF} suministra las bases para la interoperabilidad con otras herramientas y aplicaciones basadas en \emph{EMF}. Dentro de \emph{EMF} encontramos un metamodelo para describir modelos llamado Ecore, este metamodelo incluye soporte en tiempo de ejecución para los modelos además de notificación de cambios.
	\item \textbf{\emph{Graphical Modeling Framework}}. Es un marco de trabajo que permite el desarrollo de editores gráficos. GMF combina EMF y GEF (\emph{Graphical Editing Framework}) para el desarrollo de editores gráficos ad-hoc. De tal forma que, los elementos creados con el editor gráfico son una representación visual de cada concepto especificado en el metamodelo.
	\item \textbf{\emph{Atlas Transformation Language}}. ATL es un lenguaje de transformación de modelos basado en los estándares del
OMG \cite{OMG} y OCL 2.0 \cite{OCL}. ATL es un lenguaje declarativo e imperativo (híbrido) que permite la transformación entre modelos (M2M). Las construcciones declarativas son la opción preferida para escribir las transformaciones debido a que permiten expresar correspondencias, entre los elementos del modelo fuente y del modelo destino a partir de una serie de composiciones de reglas. Las construcciones imperativas proporcionan constructores para facilitar la especificación de correspondencias que de forma declarativa serían más complejas de implementar.
\end{itemize}

\subsection{Editor Gráfico para la Especificación de Requisitos Web (\emph{WebREd})}

Este apartado son implementados los conceptos (sintaxis abstracta) del marco de modelado \emph{i*} y la clasificación de requisitos presentada en \cite{EscalonaK04} para proveer al diseñador con un editor gráfico para la especificación de requisitos Web. Concretamente, el metamodelo de requisitos implementado en la tesis doctoral ha sido extendido para incorporar los tipos de requisitos de \emph{i*} y la taxonomía presentada en la sección \ref{especificacion}. La Figura \ref{fig:SeccionRequisitosWebMetamodelo} muestra una captura de pantalla donde puede apreciarse la implementación del metamodelo en \emph{Eclipse}. La sintáxis concreta del metamodelo para requisitos Web se ha implementado para desarrollar un editor gráfico (Figura \ref{fig:herramienta}) por medio de la tecnología GMF. 

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/Herramienta.png}
\end{center}
\caption{Editor WebREd para la especificación de requisitos Web con \emph{i*}.}
\label{fig:herramienta}
\end{figure}

El editor (Figura \ref{fig:herramienta}) WebREd (\emph{Web Requirements Editor}) brinda al diseñador de la aplicación Web una interfaz gráfica para especificar en un diagrama los requisitos funcionales y no-funcionales \emph{Softgoals} de la aplicación Web. WebREd permite la creación, modificación y actualización de la especificación de requisitos Web (diagramas). Además, cada una de las propiedades de los elementos del marco de modelado \emph{i*} pueden ser modificadas seleccionando cada elemento en la vista de propiedades (Figura \ref{fig:PropViewWebREd}). 

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/PropViewWebREd.png}
\end{center}
\caption{Vista de propiedades del editor WebREd.}
\label{fig:PropViewWebREd}
\end{figure}

Es importante destacar que además de poder especificar modelos de requisitos Web (\emph{Content}, \emph{Navigational}, \emph{Personalization}, \emph{Service} y \emph{Layout}), WebREd permite la creación de diagramas (modelos orientados a objetivos) comúnes de \emph{i*} gracias a que coloca a disposición del diseñador los elementos clásicos (\emph{Goal}, \emph{Task}, \emph{Resource} y \emph{Softgoal}) del marco de modelado \emph{i*} como puede verse en la Figura \ref{fig:paleta}, en donde se muestran los elementos que permiten la creación de cada elemento \emph{i*} realizando un \emph{drag and drop} de cada elemento sobre el diagrama. Por último, como se mencionó anteriormente, la propuesta presentada en la tesis doctoral se encuentra alineada con MDA, por lo tanto, el editor WebREd corresponde al modelo independiente de computación (CIM).


\begin{figure}
\begin{center}
\includegraphics[width=0.3\textwidth]{img/paleta.png}
\end{center}
\caption{Elementos para el diseño del modelo de requisitos Web con \emph{i*}.}
\label{fig:paleta}
\end{figure}


\subsection{Transformaciones Modelo a Modelo (M2M)}

Con el fin de automatizar el paso del CIM al PIM, se ha desarrollado una serie de reglas de transformación definidas formalmente en el lenguaje QVT (sección \ref{reglas}) con el fin de aprovechar cada una de las ventajas que ofrece la ingeniería dirigida por modelos. Con esta idea, las transformaciones deben de ser vistas desde una perspectiva de modelado como modelos de transformaciones \cite{bezivin2006model}. En la investigación asociada a la tesis doctoral, QVT se ha utilizado como metamodelo para formalizar las transformaciones modelo a modelo abstrayéndolas como modelos, con el fin de mejorar la comprensión del proceso de transformación. Sin embargo, una vez que las transformaciones han sido modeladas, necesitan implementarse. Como se ha mencionado anteriormente, se ha utilizado el lenguaje ATL para implementar cada una de las reglas definidas en la sección \ref{reglas} y de esta forma ejecutarlas con el fin de realizar el proceso de normalización de forma automática. Cabe destacar que utilizar ATL para implementar transformaciones QVT es factible debido a la alineación que existe entre la arquitectura de ambos de lenguajes \cite{jouault2006architectural}.

La Figura \ref{fig:Content2DomainClass} muestra el código ATL referente a la implementación de la regla \emph{Content2DomainClass} (descrita en detalle en la sección \ref{reglas}. La regla tiene como objetivo crear las clases del modelo de dominio de A-OOH.

%El metamodelo de navegación en A-OOH se implementa en este módulo. El metamodelo definido formalmente en la Figura \ref{fig:navmetamodel} define la sintaxis abstracta para la representación conceptual en un PIM del modelo de navegación de A-OOH.

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/Content2DomainClasATL.png}
\end{center}
\caption{Implementación de la transformación \emph{Content2DomainClass} en el lenguaje ATL.}
\label{fig:Content2DomainClass}
\end{figure}


\subsection{Caso de estudio}

En este apartado se presenta un caso de estudio para demostrar la aplicabilidad de nuestra propuesta. El caso de estudio es acerca de una aplicación Web para la gestión de conferencias (\emph{Conference Management System})\footnote{La especificación completa del caso de estudio se encuentra en \url{http://users.dsic.upv.es/~west/iwwost01}}. El porpósito de la aplicación Web es brindar soporte al proceso de envío, evaluación y selección de los artículos para una conferencia. Para efectos demostrativos, en este caso de estudio nos enfocaremos en la obtención del modelo de dominio, navegación y trazabilidad a partir de la especificación de requisitos.

El primer paso consiste en la especificación de los requisitos para la aplicación Web ``\emph{ContentManagementSystem}''. La Figura \ref{fig:imp:reqcasoestudio}, muestra la especificación de requisitos de la aplicación Web (modelo de requisitos de A-OOH). El objetivo de la aplicación Web consiste en ``\emph{Process of review of papers be selected}'', para satisfacer el objetivo, es necesario la implementación de alguno de los requisitos navegacionales ``\emph{Blind review process}'' y ``\emph{Normal review process}''. En este ejemplo el objetivo es logrado a través del requisito navegacional ``\emph{Blind review process}''. 

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/EjemploImplementacionTesisRequisitos.png}
\end{center}
\caption{Especificación de requisitos Web con \emph{i*} para el caso de estudio.}
\label{fig:imp:reqcasoestudio}
\end{figure}

El siguiente paso consiste en ejecutar las reglas de transformación para derivar automáticamente el modelo de dominio de A-OOH. En la Figura \ref{fig:imp:Service2ClassOperationATL} se muestra la regla de transformación \emph{Service2ClassOperation} (definida en la sección \ref{reglas}) implementada en ATL. 

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/Service2ClassOperationATL.png}
\end{center}
\caption{Reglas ATL para obtener las operaciones de las clases del modelo de dominio A-OOH.}
\label{fig:imp:Service2ClassOperationATL}
\end{figure}

En este caso de estudio, el modelo de dominio de A-OOH se muestra en la Figura \ref{fig:imp:DomainModelCaseStudy}. Como se puede observar, el modelo esta constituido por un \emph{UML-Package}, dentro del cual se encuentran los elementos comunes de un diagrama de clases UML tales como las clases, las operaciones dentro de las clases y las asociaciones.

\begin{figure}
\begin{center}
\includegraphics[width=0.9\textwidth]{img/DomainModelCaseStudy.png}
\end{center}
\caption{Modelo de dominio A-OOH.}
\label{fig:imp:DomainModelCaseStudy}
\end{figure}

Al mismo tiempo que ocurre la generación del modelo de dominio de A-OOH se obtiene el modelo de trazabilidad (Sección \ref{c1:trazabilidad}). Esto es debido a que las reglas para crear los enlaces para trazabilidad están introducidas en las reglas ATL que derivan los modelos conceptuales. La Figura \ref{fig:imp:TraceModelReqDomain} muestra la parte de la transformación ATL donde se genera el modelo de trazabilidad.

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/TraceModelReqDomain.png}
\end{center}
\caption{Extracto de la regla ATL para obtener el modelo de dominio en donde se crea el modelo de trazabilidad.}
\label{fig:imp:TraceModelReqDomain}
\end{figure}

El próximo paso consiste en visualizar el modelo de trazabilidad obtenido por medio de la herramienta AMW \emph{Atlas Model Weaver}  \cite{AtlasModelWeaver}. AMW es una herramienta que permite visualizar los enlaces contenidos en los modelos de \emph{weaving}. En la Figura \ref{fig:imp:TrazabilidadAtlasModelWeaver} se muestra el soporte para trazabilidad de A-OOH, en el lado izquiero de la imágen se visualiza el modelo de requisitos, al centro el modelo de trazabilidad y en el lado derecho se puede observar el modelo de dominio. Cuando el diseñador selecciona algún elemento de cualquier modelo (requisitos, trazabilidad o dominio) la herramienta resalta los respectivos elementos con los que corresponde el elemento seleccionado. Por último, en la parte inferior de la figura se pueden ver las propiedades de los elementos del modelo de trazabilidad.

\begin{landscape}
\begin{figure}
\begin{center}
\includegraphics[width=1.5\textwidth]{img/TrazabilidadAtlasModelWeaver.png}
\end{center}
\caption{Visualización del modelo de trazabilidad en la herramienta AMW.}
\label{fig:imp:TrazabilidadAtlasModelWeaver}
\end{figure}
\end{landscape}


El último paso es la obtención del modelo de navegación de A-OOH. En este caso de estudio existe una implementación en ATL (Figura \ref{fig:imp:CreateNavigationalModelATL}) de las reglas de transformación presentadas en la sección \ref{reglas} para deribar automáticamente el modelo de navegación. El proceso de derivación de un modelo de navegación permite obtener un modelo conceptual donde se especifiquen las rutas que el usuario de la aplicación Web podrá utilizar para desplazarse por el contenido. En la Figura \ref{fig:imp:NavigationalMetamodelCaseStudy} se muestra el modelo de navegación obtenido automáticamente a partir del modelo de requisitos. Como se describio en la sección \ref{modelos}, el modelo de navegación esta constituido por clases navegacionales, enlaces navegacionales y nodos navegacionales. Una vez que se tiene este modelo, queda concluido el caso de estudio.

\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/CreateNavigationalModelATL.png}
\end{center}
\caption{Extracto de la regla ATL para obtener el modelo de navegación.}
\label{fig:imp:CreateNavigationalModelATL}
\end{figure}


%\begin{landscape}
\begin{figure}
\begin{center}
\includegraphics[width=\textwidth]{img/NavigationalMetamodelCaseStudy.png}
\end{center}
\caption{Modelo de navegación del caso de estudio.}
\label{fig:imp:NavigationalMetamodelCaseStudy}
\end{figure}
%\end{landscape}



\clearpage


\section{Conclusiones}

La Web cambia constantemente debido a la evolución constante en las tecnologías de implementación. Por tanto, las metodologías ingenieríles necesitan adaptarse a los cambios con el fin de ofrecer al diseñador una aproximación sistemática e integral para el desarrollo de aplicaciones Web. Además, debido a la naturaleza cambiante de la Web y a su audiencia heterogénea, mantener una etapa de análisis y especificación de requisitos resulta cada vez más complicado. 

Para tratar con estas cuestiones, en esta tesis doctoral, se ha
presentado una propuesta dirigida por modelos que permite (i) la
especificación de un modelo de requisitos a nivel conceptual de manera
integral, sistemática y bien estructurada y (ii) la derivación
automática de los modelos conceptuales de dominio y navegación. Por lo tanto, la propuesta permite a los diseñadores disminuir el nivel de complejidad en el desarrollo de aplicaciones Web, ahorrando tiempo y esfuerzo con lo que el costo del proyecto disminuye. Posteriormente, se ha añadido a la propuesta dirigida por modelos un soporte al diseñador por medio de una gestión integral de requisitos con el fin de asegurar la la trazabilidad de los requisitos de CIM a PIM, análisis de impacto y la implementación de requisitos funcionales en base a distintas alternativas de diseño considerando la maximización de los requisitos no-funcionales. También, se ha realizado una implementación en \emph{Eclipse} para apoyar cada parte de esta propuesta.

Finalmente, cabe destacar que la tesis doctoral representa la
primera propuesta dirigida por modelos en ingeniería Web que aplica un marco de trabajo orientado a objetivos para la etapa de análisis y especificación de requisitos en un contexto MDA, a la vez permite la generación de los modelos conceptuales de la aplicación Web en un proceso con un alto grado de automatización.

%\textbf{Not only an approach that deals with the MD modeling of DWs
%has been defined but also a general framework to align the
%development of every part of a DW with MDA (see chapter~\ref{c3}),
%thus paving the way for future research objectives as the modeling
%of ETL process or data analysis tools...}

\clearpage



\bibliographystyle{abbrv}
\bibliography{tesis}


%
